<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Поиск лучших компаний по нише</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: #0f1117;
      color: #e1e4e8;
      min-height: 100vh;
      padding-top: 50px;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 40px 20px;
    }

    h1 {
      text-align: center;
      font-size: 28px;
      margin-bottom: 8px;
      color: #fff;
    }

    .subtitle {
      text-align: center;
      color: #8b949e;
      margin-bottom: 32px;
      font-size: 15px;
    }

    .form-section {
      max-width: 600px;
      margin: 0 auto 40px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .input-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .input-group label {
      font-size: 13px;
      color: #8b949e;
      font-weight: 500;
    }

    input[type="text"], input[type="password"] {
      padding: 12px 16px;
      border: 1px solid #30363d;
      border-radius: 8px;
      background: #161b22;
      color: #e1e4e8;
      font-size: 15px;
      outline: none;
      transition: border-color 0.2s;
    }

    input:focus, select:focus {
      border-color: #58a6ff;
    }

    select {
      padding: 12px 16px;
      border: 1px solid #30363d;
      border-radius: 8px;
      background: #161b22;
      color: #e1e4e8;
      font-size: 15px;
      outline: none;
      transition: border-color 0.2s;
      cursor: pointer;
    }

    .field-hint {
      font-size: 12px;
      color: #888;
      margin-top: 2px;
      line-height: 1.4;
    }

    .prompt-preview {
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 8px;
      padding: 12px 16px;
      font-size: 14px;
      color: #8b949e;
      line-height: 1.6;
    }

    .prompt-preview .highlight {
      color: #58a6ff;
      font-weight: 600;
    }

    button {
      padding: 12px 24px;
      background: #238636;
      color: #fff;
      border: none;
      border-radius: 8px;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s;
    }

    button:hover { background: #2ea043; }
    button:disabled {
      background: #21262d;
      color: #484f58;
      cursor: not-allowed;
    }

    .results {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
      gap: 20px;
    }

    .result-card {
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 12px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .result-header {
      padding: 16px 20px;
      border-bottom: 1px solid #30363d;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .model-badge {
      padding: 4px 10px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 600;
      color: #fff;
    }

    .badge-chatgpt { background: #10a37f; }
    .badge-gemini { background: #4285f4; }
    .badge-claude { background: #d97706; }

    .model-name {
      font-weight: 600;
      font-size: 15px;
    }

    .chat-messages {
      padding: 0;
      max-height: 600px;
      overflow-y: auto;
      flex: 1;
    }

    .chat-messages::-webkit-scrollbar {
      width: 6px;
    }

    .chat-messages::-webkit-scrollbar-thumb {
      background: #30363d;
      border-radius: 3px;
    }

    .chat-msg {
      padding: 14px 20px;
      font-size: 14px;
      line-height: 1.7;
      white-space: pre-wrap;
      border-bottom: 1px solid #1c2129;
    }

    .chat-msg-user {
      background: #1c2333;
    }

    .chat-msg-user .chat-msg-label {
      color: #58a6ff;
      font-weight: 600;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 6px;
    }

    .chat-msg-assistant .chat-msg-label {
      color: #8b949e;
      font-weight: 600;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 6px;
    }

    .error-text { color: #f85149; }

    .chat-input-area {
      display: flex;
      gap: 8px;
      padding: 12px 16px;
      border-top: 1px solid #30363d;
      background: #0d1117;
    }

    .chat-input-area input {
      flex: 1;
      padding: 10px 14px;
      border: 1px solid #30363d;
      border-radius: 8px;
      background: #161b22;
      color: #e1e4e8;
      font-size: 14px;
      outline: none;
    }

    .chat-input-area input:focus {
      border-color: #58a6ff;
    }

    .chat-input-area button {
      padding: 10px 16px;
      font-size: 13px;
      white-space: nowrap;
    }

    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 40px;
      color: #8b949e;
    }

    .spinner {
      width: 20px;
      height: 20px;
      border: 2px solid #30363d;
      border-top-color: #58a6ff;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    .spinner-small {
      width: 14px;
      height: 14px;
      border: 2px solid #30363d;
      border-top-color: #58a6ff;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      display: inline-block;
    }

    @keyframes spin { to { transform: rotate(360deg); } }

    .grok-table-wrap table {
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
    }

    .grok-table-wrap th {
      background: #1c2333;
      color: #58a6ff;
      text-align: left;
      padding: 10px 14px;
      border: 1px solid #30363d;
      font-weight: 600;
    }

    .grok-table-wrap td {
      padding: 10px 14px;
      border: 1px solid #30363d;
      line-height: 1.5;
    }

    .grok-table-wrap tr:nth-child(even) {
      background: #161b22;
    }

    .grok-table-wrap tr:nth-child(odd) {
      background: #0d1117;
    }

    .xml-output {
      background: #0d1117;
      border: 1px solid #30363d;
      border-radius: 8px;
      padding: 20px;
      font-family: "SF Mono", "Fira Code", "Consolas", monospace;
      font-size: 13px;
      line-height: 1.7;
      white-space: pre-wrap;
      word-break: break-word;
      overflow-x: auto;
      color: #e1e4e8;
    }

    .xml-output .xml-tag { color: #7ee787; }
    .xml-output .xml-attr { color: #d2a8ff; }
    .xml-output .xml-val { color: #a5d6ff; }
    .xml-output .xml-text { color: #e1e4e8; }

    .copy-btn {
      padding: 6px 14px;
      font-size: 12px;
      background: #21262d;
      color: #8b949e;
      border: 1px solid #30363d;
      border-radius: 6px;
      cursor: pointer;
      float: right;
      margin-bottom: 10px;
    }

    .copy-btn:hover {
      background: #30363d;
      color: #e1e4e8;
    }

    .canvas-toolbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 16px;
      border-bottom: 1px solid #30363d;
      background: #0d1117;
    }

    .canvas-tabs {
      display: flex;
      gap: 4px;
    }

    .canvas-tab {
      padding: 6px 16px;
      font-size: 13px;
      background: transparent;
      color: #8b949e;
      border: 1px solid transparent;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 500;
    }

    .canvas-tab:hover {
      color: #e1e4e8;
      background: #161b22;
    }

    .canvas-tab.active {
      background: #238636;
      color: #fff;
      border-color: #238636;
    }

    .canvas-frame {
      width: 100%;
      min-height: 800px;
      border: none;
      background: #fff;
      border-radius: 0 0 12px 12px;
    }

    .canvas-code {
      background: #0d1117;
      padding: 20px;
      font-family: "SF Mono", "Fira Code", "Consolas", monospace;
      font-size: 12px;
      line-height: 1.6;
      color: #e1e4e8;
      overflow-x: auto;
      white-space: pre-wrap;
      word-break: break-word;
      max-height: 800px;
      overflow-y: auto;
      margin: 0;
    }

    .companies-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 10px;
      margin-bottom: 20px;
    }

    .company-btn {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px 14px;
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 8px;
      color: #e1e4e8;
      font-size: 13px;
      cursor: pointer;
      transition: border-color 0.2s, background 0.2s;
      text-align: left;
      width: 100%;
    }

    .company-btn:hover { border-color: #58a6ff; background: #1c2333; }
    .company-btn.status-done { border-color: #238636; }
    .company-btn.status-error { border-color: #f85149; }
    .company-btn.status-loading { border-color: #d29922; }

    .company-status-icon {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .company-status-icon.pending { background: #484f58; }
    .company-status-icon.loading { background: #d29922; animation: pulse 1s infinite; }
    .company-status-icon.done { background: #238636; }
    .company-status-icon.error { background: #f85149; }

    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }

    .company-preview-frame {
      width: 100%;
      height: 500px;
      border: 1px solid #30363d;
      border-radius: 8px;
      background: #fff;
    }

    .fill-section {
      margin-top: 20px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .fill-section textarea {
      width: 100%;
      min-height: 120px;
      padding: 12px 16px;
      border: 1px solid #30363d;
      border-radius: 8px;
      background: #161b22;
      color: #e1e4e8;
      font-size: 14px;
      font-family: inherit;
      resize: vertical;
      outline: none;
    }

    .fill-section textarea:focus { border-color: #58a6ff; }
    .fill-section textarea::placeholder { color: #484f58; }

    .download-progress {
      font-size: 13px;
      color: #8b949e;
      margin-bottom: 8px;
    }

    .api-key-toggle {
      font-size: 12px;
      color: #58a6ff;
      cursor: pointer;
      background: none;
      border: none;
      padding: 0;
      font-weight: 400;
    }

    .api-key-toggle:hover {
      text-decoration: underline;
      background: none;
    }

    /* --- Editor toolbar --- */
    .editor-toolbar {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 16px;
      background: #161b22;
      border-bottom: 1px solid #30363d;
      flex-wrap: wrap;
    }

    .editor-toggle {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 13px;
      color: #8b949e;
      cursor: pointer;
      user-select: none;
    }

    .editor-toggle input[type="checkbox"] {
      accent-color: #238636;
      width: 16px;
      height: 16px;
    }

    .editor-btn {
      padding: 4px 12px;
      font-size: 12px;
      background: #21262d;
      color: #8b949e;
      border: 1px solid #30363d;
      border-radius: 6px;
      cursor: pointer;
    }

    .editor-btn:hover:not(:disabled) {
      background: #30363d;
      color: #e1e4e8;
    }

    .editor-btn:disabled {
      opacity: 0.4;
      cursor: default;
    }

    .editor-btn-primary {
      background: #238636;
      color: #fff;
      border-color: #238636;
    }

    .editor-btn-primary:hover {
      background: #2ea043;
    }

    /* --- SEO Panel --- */
    .seo-panel {
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 12px;
      padding: 20px;
      margin-top: 16px;
      display: none;
    }

    .seo-panel h3 {
      font-size: 16px;
      color: #e1e4e8;
      margin-bottom: 16px;
    }

    .seo-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }

    .seo-field {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .seo-field.full-width {
      grid-column: 1 / -1;
    }

    .seo-field label {
      font-size: 13px;
      color: #8b949e;
      font-weight: 500;
    }

    .seo-field input,
    .seo-field textarea {
      background: #0d1117;
      border: 1px solid #30363d;
      border-radius: 6px;
      color: #e1e4e8;
      padding: 8px 12px;
      font-size: 13px;
      font-family: inherit;
    }

    .seo-field textarea {
      min-height: 60px;
      resize: vertical;
    }

    .seo-field .field-hint {
      color: #6e7681;
      font-size: 11px;
    }

    .seo-actions {
      margin-top: 12px;
      display: flex;
      gap: 8px;
      justify-content: flex-end;
    }

    .seo-notification {
      position: fixed;
      bottom: 24px;
      right: 24px;
      background: #238636;
      color: #fff;
      padding: 10px 20px;
      border-radius: 8px;
      font-size: 13px;
      z-index: 10000;
      animation: fadeInOut 2.5s ease forwards;
    }

    @keyframes fadeInOut {
      0% { opacity: 0; transform: translateY(10px); }
      15% { opacity: 1; transform: translateY(0); }
      80% { opacity: 1; }
      100% { opacity: 0; }
    }

    /* Projects list */
    .projects-section {
      margin-bottom: 32px;
      border: 1px solid #30363d;
      border-radius: 12px;
      background: #161b22;
      overflow: hidden;
    }
    .projects-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 20px;
      background: #1c2128;
      border-bottom: 1px solid #30363d;
      cursor: pointer;
    }
    .projects-header h2 {
      font-size: 16px;
      color: #fff;
      margin: 0;
    }
    .projects-header .toggle-arrow {
      color: #8b949e;
      font-size: 14px;
      transition: transform 0.2s;
    }
    .projects-header .toggle-arrow.open {
      transform: rotate(180deg);
    }
    .projects-list {
      padding: 12px;
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 12px;
      max-height: 400px;
      overflow-y: auto;
    }
    .projects-list:empty::after {
      content: 'Нет сохранённых проектов';
      color: #8b949e;
      font-size: 13px;
      padding: 20px;
      text-align: center;
      grid-column: 1 / -1;
    }
    .project-card {
      background: #0d1117;
      border: 1px solid #30363d;
      border-radius: 8px;
      padding: 14px;
      transition: border-color 0.2s;
    }
    .project-card:hover {
      border-color: #58a6ff;
    }
    .project-card .pc-niche {
      font-size: 15px;
      font-weight: 600;
      color: #fff;
      margin-bottom: 4px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .project-card .pc-geo {
      font-size: 12px;
      color: #8b949e;
      margin-bottom: 8px;
    }
    .project-card .pc-meta {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    .project-card .pc-date {
      font-size: 11px;
      color: #6e7681;
    }
    .project-card .pc-status {
      font-size: 11px;
      padding: 2px 8px;
      border-radius: 10px;
      font-weight: 500;
    }
    .pc-status.in_progress { background: #1f2d3d; color: #58a6ff; }
    .pc-status.generated { background: #1a2e1a; color: #3fb950; }
    .pc-status.filled { background: #2d1f3d; color: #bc8cff; }
    .pc-status.edited { background: #2d2a1f; color: #d29922; }
    .project-card .pc-actions {
      display: flex;
      gap: 6px;
    }
    .project-card .pc-actions button {
      flex: 1;
      padding: 5px 8px;
      font-size: 11px;
      border: 1px solid #30363d;
      border-radius: 6px;
      background: #21262d;
      color: #c9d1d9;
      cursor: pointer;
      transition: background 0.15s;
    }
    .project-card .pc-actions button:hover {
      background: #30363d;
    }
    .project-card .pc-actions button.pc-open {
      background: #238636;
      border-color: #238636;
      color: #fff;
    }
    .project-card .pc-actions button.pc-open:hover {
      background: #2ea043;
    }
    .project-card .pc-actions button.pc-delete:hover {
      background: #da3633;
      border-color: #da3633;
      color: #fff;
    }

    /* === SPA Navigation === */
    #app-nav {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 9999;
      height: 50px;
      background: #161b22;
      border-bottom: 1px solid #30363d;
      display: flex;
      align-items: center;
    }
    .nav-inner {
      max-width: 1200px;
      width: 100%;
      margin: 0 auto;
      padding: 0 20px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .nav-logo {
      font-size: 18px;
      font-weight: 700;
      color: #58a6ff;
      text-decoration: none;
      letter-spacing: 1px;
    }
    .nav-logo:hover { color: #79c0ff; }
    .nav-links { display: flex; gap: 4px; }
    .nav-link {
      padding: 8px 16px;
      font-size: 13px;
      color: #8b949e;
      text-decoration: none;
      border-radius: 6px;
      transition: background 0.15s, color 0.15s;
    }
    .nav-link:hover { background: #21262d; color: #e1e4e8; }
    .nav-link.active { background: #238636; color: #fff; }
    .screen-hidden { display: none !important; }

    /* === Dashboard === */
    #screen-dashboard {
      max-width: 1200px;
      margin: 0 auto;
      padding: 40px 20px;
    }
    .dashboard-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 32px;
    }
    .dashboard-header h1 { font-size: 24px; text-align: left; }
    .dashboard-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 16px;
    }
    .dashboard-empty {
      text-align: center;
      padding: 80px 20px;
      color: #8b949e;
    }
    .dashboard-empty p { font-size: 15px; margin-bottom: 20px; }

    /* === Project View === */
    #screen-project {
      max-width: 1000px;
      margin: 0 auto;
      padding: 40px 20px;
    }
    .project-header { margin-bottom: 24px; }
    .project-header h1 { font-size: 24px; text-align: left; margin-bottom: 8px; }
    .project-header-meta {
      display: flex;
      gap: 12px;
      align-items: center;
      color: #8b949e;
      font-size: 13px;
      flex-wrap: wrap;
    }
    .project-actions {
      display: flex;
      gap: 8px;
      margin-bottom: 24px;
      flex-wrap: wrap;
    }
    .project-actions button { padding: 8px 16px; font-size: 13px; }
    .project-preview-frame {
      width: 100%;
      min-height: 600px;
      border: 1px solid #30363d;
      border-radius: 12px;
      background: #fff;
    }
    .project-meta-section {
      margin-top: 24px;
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 12px;
    }
    .project-meta-section summary {
      padding: 12px 16px;
      cursor: pointer;
      color: #8b949e;
      font-size: 13px;
      list-style: none;
    }
    .project-meta-section summary::-webkit-details-marker { display: none; }
    .project-meta-section[open] summary { border-bottom: 1px solid #30363d; }
    .project-meta-content {
      padding: 16px;
      font-size: 13px;
      color: #8b949e;
    }

    /* === Pipeline Timeline === */
    .pipeline-timeline {
      display: flex;
      gap: 4px;
      margin-bottom: 24px;
      flex-wrap: wrap;
      align-items: center;
    }
    .pipeline-step {
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 12px;
      background: #21262d;
      color: #8b949e;
      border: 1px solid #30363d;
      white-space: nowrap;
      transition: all 0.3s;
    }
    .pipeline-step.done { background: #0d1117; color: #3fb950; border-color: #238636; }
    .pipeline-step.running { background: #0d1117; color: #d29922; border-color: #9e6a03; }
    .pipeline-step.error { background: #0d1117; color: #f85149; border-color: #da3633; }
    .pipeline-arrow { color: #30363d; font-size: 14px; }

    /* === Project Pipeline Results === */
    .project-pipeline-results { margin-top: 24px; }
    .project-pipeline-results .result-card { margin-bottom: 16px; }

    .project-result-actions {
      display: flex;
      gap: 8px;
      margin: 24px 0;
      flex-wrap: wrap;
    }
    .project-result-actions button { padding: 8px 16px; font-size: 13px; }

    .project-resume-bar {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 16px;
      background: #161b22;
      border: 1px solid #9e6a03;
      border-radius: 12px;
      margin-bottom: 24px;
      color: #d29922;
      font-size: 14px;
    }
    .project-resume-bar button { white-space: nowrap; }
  </style>
</head>
<body>
  <nav id="app-nav">
    <div class="nav-inner">
      <a href="#/" class="nav-logo">NRG</a>
      <div class="nav-links">
        <a href="#/" class="nav-link" id="nav-link-dashboard">Проекты</a>
        <a href="#/generator" class="nav-link" id="nav-link-generator">Новый проект</a>
      </div>
    </div>
  </nav>

  <div id="screen-dashboard" class="screen-hidden"></div>

  <div id="screen-generator" class="screen-hidden">
  <div class="container">
    <h1>30 лучших компаний по нише</h1>
    <p class="subtitle">Введите нишу — получите списки от трёх нейросетей через OpenRouter</p>

    <div class="form-section">
      <div class="input-group">
        <label>
          API-ключ OpenRouter
          <button class="api-key-toggle" onclick="toggleApiKey()" id="toggleBtn">показать</button>
        </label>
        <input type="password" id="apiKey" placeholder="sk-or-..." />
      </div>

      <div class="input-group">
        <label>Название ниши</label>
        <input type="text" id="niche" placeholder="например: кибербезопасность" oninput="updatePreview()" />
        <span class="field-hint">Укажите нишу или тематику для поиска компаний. Пример: аренда авто, кибербезопасность</span>
      </div>

      <div class="input-group">
        <label>Гео ниши <span style="color:#8b949e; font-weight:400;">(необязательно)</span></label>
        <input type="text" id="geo" placeholder="например: Москва, Россия, Казахстан..." oninput="updatePreview()" />
        <span class="field-hint">Где работают компании. Оставьте пустым для глобального поиска. Пример: Калифорния, Москва</span>
      </div>

      <div class="input-group">
        <label>Гео запроса <span style="color:#8b949e; font-weight:400;">(необязательно)</span></label>
        <input type="text" id="geoRequest" placeholder="например: Москва, New York..." />
        <span class="field-hint">Откуда вы ищете — влияет на релевантность выдачи с учётом вашей локации. Пример: Москва, New York</span>
      </div>

      <div class="input-group">
        <label>Язык запросов</label>
        <select id="queryLang">
          <option value="Русский">Русский</option>
          <option value="English">English</option>
          <option value="Deutsch">Deutsch</option>
          <option value="Français">Français</option>
          <option value="Español">Español</option>
          <option value="中文">中文</option>
          <option value="日本語">日本語</option>
        </select>
        <span class="field-hint">На каком языке модели будут искать и анализировать компании</span>
      </div>

      <div class="input-group">
        <label>Язык сайта</label>
        <select id="siteLang">
          <option value="Русский">Русский</option>
          <option value="English">English</option>
          <option value="Deutsch">Deutsch</option>
          <option value="Français">Français</option>
          <option value="Español">Español</option>
          <option value="中文">中文</option>
          <option value="日本語">日本語</option>
        </select>
        <span class="field-hint">На каком языке будет сгенерирован итоговый рейтинговый сайт</span>
      </div>

      <div class="input-group">
        <label>Данные вашей компании <span style="color:#8b949e; font-weight:400;">(необязательно)</span></label>
        <textarea id="user-company-data" placeholder="Название компании, описание услуг, преимущества, цены, отзывы клиентов..." style="min-height:80px;"></textarea>
        <span class="field-hint">Если указать — компания станет #1 в итоговом рейтинге с бейджем «Выбор редакции»</span>
      </div>

      <div class="prompt-preview" id="preview">
        Составь список 30 <span class="highlight">...</span>
      </div>

      <button id="searchBtn" onclick="startProject()" style="width:100%;">Создать проект</button>

      <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #30363d; display:flex; justify-content:space-between; align-items:center;">
        <details style="flex:1;">
          <summary style="cursor:pointer; font-size:13px; color:#8b949e;">Быстрый тест загрузки</summary>
          <div style="margin-top: 8px; display:flex; gap:8px;">
            <input type="text" id="testUrl" placeholder="https://example.com" style="flex:1;" />
            <button onclick="testDownload()" style="white-space:nowrap;">Тест</button>
          </div>
          <div id="testResult" style="margin-top:8px; font-size:12px; color:#8b949e; white-space:pre-wrap;"></div>
        </details>
        <a href="test-download.html" style="font-size:13px; color:#58a6ff; text-decoration:none; margin-left:12px;">Полный тест скачивания →</a>
      </div>
    </div>

  </div>
  </div><!-- /screen-generator -->

  <div id="screen-project" class="screen-hidden"></div>

  <script>
    // === Projects: localStorage ===
    let currentProjectId = null;
    const PROJECTS_KEY = 'nrg_projects';

    const STATUS_LABELS = {
      in_progress: 'Генерация',
      generated: 'Сгенерирован',
      filled: 'Наполнен',
      edited: 'Отредактирован'
    };

    // === SPA Router ===
    function router() {
      const hash = location.hash || '#/';

      // Hide all screens
      document.getElementById('screen-dashboard').classList.add('screen-hidden');
      document.getElementById('screen-generator').classList.add('screen-hidden');
      document.getElementById('screen-project').classList.add('screen-hidden');

      // Remove active state from nav links
      document.querySelectorAll('.nav-link').forEach(l => l.classList.remove('active'));

      if (hash === '#/' || hash === '#' || hash === '') {
        document.getElementById('screen-dashboard').classList.remove('screen-hidden');
        document.getElementById('nav-link-dashboard').classList.add('active');
        renderDashboard();
      } else if (hash === '#/generator') {
        document.getElementById('screen-generator').classList.remove('screen-hidden');
        document.getElementById('nav-link-generator').classList.add('active');
      } else if (hash.startsWith('#/project/')) {
        const id = hash.split('/')[2];
        document.getElementById('screen-project').classList.remove('screen-hidden');
        document.getElementById('nav-link-dashboard').classList.add('active');
        renderProject(id);
      } else {
        location.hash = '#/';
      }
    }

    window.addEventListener('hashchange', router);

    // === Dashboard ===
    function renderDashboard() {
      const projects = getProjects();
      const container = document.getElementById('screen-dashboard');

      if (projects.length === 0) {
        container.innerHTML = `
          <div class="dashboard-header">
            <h1>Мои проекты</h1>
          </div>
          <div class="dashboard-empty">
            <p>У вас пока нет проектов</p>
            <button onclick="location.hash='#/generator'">Создать первый проект</button>
          </div>
        `;
        return;
      }

      const cardsHtml = projects.map(p => `
        <div class="project-card" data-id="${p.id}">
          <div class="pc-niche">${escHtml(p.niche)}</div>
          ${p.geo ? `<div class="pc-geo">${escHtml(p.geo)}</div>` : ''}
          <div class="pc-meta">
            <span class="pc-date">${new Date(p.updated_at || p.created_at).toLocaleDateString('ru-RU', {
              day: 'numeric', month: 'short', year: 'numeric'
            })}</span>
            <span class="pc-status ${p.status}">${STATUS_LABELS[p.status] || p.status}</span>
          </div>
          <div class="pc-actions">
            <button class="pc-open" onclick="location.hash='#/project/${p.id}'">Открыть</button>
            <button onclick="duplicateProject('${p.id}')">Дубл.</button>
            <button class="pc-delete" onclick="deleteProject('${p.id}')">Удалить</button>
          </div>
        </div>
      `).join('');

      container.innerHTML = `
        <div class="dashboard-header">
          <h1>Мои проекты <span style="color:#8b949e; font-weight:400;">(${projects.length})</span></h1>
          <button onclick="location.hash='#/generator'">+ Новый проект</button>
        </div>
        <div class="dashboard-grid">
          ${cardsHtml}
        </div>
      `;
    }

    function getProjects() {
      try { return JSON.parse(localStorage.getItem(PROJECTS_KEY) || '[]'); }
      catch { return []; }
    }

    function saveProjects(projects) {
      localStorage.setItem(PROJECTS_KEY, JSON.stringify(projects));
    }

    // ============ BM25 SEARCH ENGINE (ported from ui-ux-pro-max/core.py) ============
    class BM25 {
      constructor(k1 = 1.5, b = 0.75) {
        this.k1 = k1;
        this.b = b;
        this.corpus = [];
        this.docLengths = [];
        this.avgdl = 0;
        this.idf = {};
        this.docFreqs = {};
        this.N = 0;
      }

      tokenize(text) {
        return String(text).toLowerCase().replace(/[^\w\s]/g, ' ')
          .split(/\s+/).filter(w => w.length > 2);
      }

      fit(documents) {
        this.corpus = documents.map(d => this.tokenize(d));
        this.N = this.corpus.length;
        if (this.N === 0) return;
        this.docLengths = this.corpus.map(d => d.length);
        this.avgdl = this.docLengths.reduce((a, b) => a + b, 0) / this.N;
        this.docFreqs = {};
        for (const doc of this.corpus) {
          const seen = new Set();
          for (const word of doc) {
            if (!seen.has(word)) {
              this.docFreqs[word] = (this.docFreqs[word] || 0) + 1;
              seen.add(word);
            }
          }
        }
        this.idf = {};
        for (const [word, freq] of Object.entries(this.docFreqs)) {
          this.idf[word] = Math.log((this.N - freq + 0.5) / (freq + 0.5) + 1);
        }
      }

      score(query) {
        const queryTokens = this.tokenize(query);
        const scores = [];
        for (let idx = 0; idx < this.corpus.length; idx++) {
          let score = 0;
          const doc = this.corpus[idx];
          const docLen = this.docLengths[idx];
          const termFreqs = {};
          for (const word of doc) termFreqs[word] = (termFreqs[word] || 0) + 1;
          for (const token of queryTokens) {
            if (this.idf[token] !== undefined) {
              const tf = termFreqs[token] || 0;
              const idfVal = this.idf[token];
              const num = tf * (this.k1 + 1);
              const den = tf + this.k1 * (1 - this.b + this.b * docLen / this.avgdl);
              score += idfVal * num / den;
            }
          }
          scores.push([idx, score]);
        }
        scores.sort((a, b) => b[1] - a[1]);
        return scores;
      }
    }

    // ============ DESIGN DATA CONFIG (ported from ui-ux-pro-max) ============
    const DESIGN_CSV_CONFIG = {
      style: {
        file: 'styles.json',
        searchCols: ['Style Category', 'Keywords', 'Best For', 'Type'],
        outputCols: ['Style Category', 'Type', 'Keywords', 'Primary Colors', 'Effects & Animation', 'Best For', 'Performance', 'Accessibility']
      },
      color: {
        file: 'colors.json',
        searchCols: ['Product Type', 'Keywords', 'Notes'],
        outputCols: ['Product Type', 'Keywords', 'Primary (Hex)', 'Secondary (Hex)', 'CTA (Hex)', 'Background (Hex)', 'Text (Hex)', 'Notes']
      },
      landing: {
        file: 'landing.json',
        searchCols: ['Pattern Name', 'Keywords', 'Conversion Optimization', 'Section Order'],
        outputCols: ['Pattern Name', 'Keywords', 'Section Order', 'Primary CTA Placement', 'Color Strategy', 'Conversion Optimization']
      },
      product: {
        file: 'products.json',
        searchCols: ['Product Type', 'Keywords', 'Primary Style Recommendation', 'Key Considerations'],
        outputCols: ['Product Type', 'Keywords', 'Primary Style Recommendation', 'Color Palette Focus']
      },
      typography: {
        file: 'typography.json',
        searchCols: ['Font Pairing Name', 'Category', 'Mood/Style Keywords', 'Best For', 'Heading Font', 'Body Font'],
        outputCols: ['Font Pairing Name', 'Heading Font', 'Body Font', 'Mood/Style Keywords', 'Best For', 'Google Fonts URL', 'CSS Import']
      }
    };

    const designDataCache = {};

    async function loadDesignData(filename) {
      if (designDataCache[filename]) return designDataCache[filename];
      const resp = await fetch('/design-data/' + filename);
      if (!resp.ok) throw new Error('Failed to load ' + filename);
      const data = await resp.json();
      designDataCache[filename] = data;
      return data;
    }

    async function searchDesignCSV(domain, query, maxResults = 3) {
      const config = DESIGN_CSV_CONFIG[domain];
      if (!config) return [];
      const data = await loadDesignData(config.file);
      const documents = data.map(row =>
        config.searchCols.map(col => row[col] || '').join(' ')
      );
      const bm25 = new BM25();
      bm25.fit(documents);
      const ranked = bm25.score(query);
      return ranked.slice(0, maxResults)
        .filter(([, s]) => s > 0)
        .map(([idx]) => {
          const row = data[idx];
          const result = {};
          config.outputCols.forEach(col => { if (row[col]) result[col] = row[col]; });
          return result;
        });
    }

    // ============ DESIGN SYSTEM GENERATOR (ported from design_system.py) ============

    function findReasoningRule(category, reasoningData) {
      const catLower = category.toLowerCase();
      // Pass 1: exact match
      for (const rule of reasoningData) {
        if ((rule.UI_Category || '').toLowerCase() === catLower) return rule;
      }
      // Pass 2: partial match
      for (const rule of reasoningData) {
        const uiCat = (rule.UI_Category || '').toLowerCase();
        if (uiCat.includes(catLower) || catLower.includes(uiCat)) return rule;
      }
      // Pass 3: keyword match
      for (const rule of reasoningData) {
        const uiCat = (rule.UI_Category || '').toLowerCase();
        const keywords = uiCat.replace(/\//g, ' ').replace(/-/g, ' ').split(/\s+/);
        if (keywords.some(kw => kw && catLower.includes(kw))) return rule;
      }
      return null;
    }

    function applyReasoning(category, reasoningData) {
      const rule = findReasoningRule(category, reasoningData);
      if (!rule) {
        return {
          pattern: 'Hero + Features + CTA',
          stylePriority: ['Minimalism', 'Flat Design'],
          colorMood: 'Professional',
          typographyMood: 'Clean',
          keyEffects: 'Subtle hover transitions',
          antiPatterns: '',
          severity: 'MEDIUM'
        };
      }
      let decisionRules = {};
      try { decisionRules = JSON.parse(rule.Decision_Rules || '{}'); } catch {}
      return {
        pattern: rule.Recommended_Pattern || '',
        stylePriority: (rule.Style_Priority || '').split('+').map(s => s.trim()).filter(Boolean),
        colorMood: rule.Color_Mood || '',
        typographyMood: rule.Typography_Mood || '',
        keyEffects: rule.Key_Effects || '',
        antiPatterns: rule.Anti_Patterns || '',
        decisionRules,
        severity: rule.Severity || 'MEDIUM'
      };
    }

    function selectBestMatch(results, priorityKeywords) {
      if (!results.length) return {};
      if (!priorityKeywords || !priorityKeywords.length) return results[0];
      // Strategy 1: exact style name match
      for (const priority of priorityKeywords) {
        const pLower = priority.toLowerCase().trim();
        for (const result of results) {
          const styleName = (result['Style Category'] || '').toLowerCase();
          if (pLower.includes(styleName) || styleName.includes(pLower)) return result;
        }
      }
      // Strategy 2: scored keyword match
      const scored = results.map(result => {
        const resultStr = JSON.stringify(result).toLowerCase();
        let score = 0;
        for (const kw of priorityKeywords) {
          const kwLower = kw.toLowerCase().trim();
          if ((result['Style Category'] || '').toLowerCase().includes(kwLower)) score += 10;
          else if ((result['Keywords'] || '').toLowerCase().includes(kwLower)) score += 3;
          else if (resultStr.includes(kwLower)) score += 1;
        }
        return { score, result };
      });
      scored.sort((a, b) => b.score - a.score);
      return scored[0].score > 0 ? scored[0].result : results[0];
    }

    async function generateDesignSystem(query, projectName) {
      // Step 1: Search products → category
      const reasoningData = await loadDesignData('ui-reasoning.json');
      const productResults = await searchDesignCSV('product', query, 1);
      const category = productResults[0]?.['Product Type'] || 'General';

      // Step 2: Apply reasoning rules
      const reasoning = applyReasoning(category, reasoningData);
      const stylePriority = reasoning.stylePriority;

      // Step 3: Multi-domain search (style biased by stylePriority)
      const styleQuery = stylePriority.length
        ? `${query} ${stylePriority.slice(0, 2).join(' ')}`
        : query;
      const [styleResults, colorResults, landingResults, typographyResults] = await Promise.all([
        searchDesignCSV('style', styleQuery, 3),
        searchDesignCSV('color', query, 2),
        searchDesignCSV('landing', query, 2),
        searchDesignCSV('typography', query, 2)
      ]);

      // Step 4: Select best matches
      const bestStyle = selectBestMatch(styleResults, stylePriority);
      const bestColor = colorResults[0] || {};
      const bestTypography = typographyResults[0] || {};
      const bestLanding = landingResults[0] || {};

      // Step 5: Assemble
      const styleEffects = bestStyle['Effects & Animation'] || '';
      const combinedEffects = styleEffects || reasoning.keyEffects;

      return {
        projectName: projectName || query.toUpperCase(),
        category,
        pattern: {
          name: bestLanding['Pattern Name'] || reasoning.pattern || 'Hero + Features + CTA',
          sections: bestLanding['Section Order'] || 'Hero > Features > CTA',
          ctaPlacement: bestLanding['Primary CTA Placement'] || 'Above fold',
          colorStrategy: bestLanding['Color Strategy'] || '',
          conversion: bestLanding['Conversion Optimization'] || ''
        },
        style: {
          name: bestStyle['Style Category'] || 'Minimalism',
          type: bestStyle['Type'] || 'General',
          effects: styleEffects,
          keywords: bestStyle['Keywords'] || '',
          bestFor: bestStyle['Best For'] || '',
          performance: bestStyle['Performance'] || '',
          accessibility: bestStyle['Accessibility'] || ''
        },
        colors: {
          primary: bestColor['Primary (Hex)'] || '#2563EB',
          secondary: bestColor['Secondary (Hex)'] || '#3B82F6',
          cta: bestColor['CTA (Hex)'] || '#F97316',
          background: bestColor['Background (Hex)'] || '#F8FAFC',
          text: bestColor['Text (Hex)'] || '#1E293B',
          notes: bestColor['Notes'] || ''
        },
        typography: {
          heading: bestTypography['Heading Font'] || 'Inter',
          body: bestTypography['Body Font'] || 'Inter',
          mood: bestTypography['Mood/Style Keywords'] || reasoning.typographyMood || '',
          bestFor: bestTypography['Best For'] || '',
          googleFontsUrl: bestTypography['Google Fonts URL'] || '',
          cssImport: bestTypography['CSS Import'] || ''
        },
        keyEffects: combinedEffects,
        antiPatterns: reasoning.antiPatterns,
        severity: reasoning.severity
      };
    }

    function formatDesignSystemForPrompt(ds) {
      const antiLines = (ds.antiPatterns || '').split('+').map(p => '- ' + p.trim()).filter(l => l !== '- ').join('\n');
      return `———————————————————————————
ДИЗАЙН-СИСТЕМА (СГЕНЕРИРОВАНА АВТОМАТИЧЕСКИ ПОД НИШУ: ${ds.category})
———————————————————————————

AESTHETIC DIRECTION: ${ds.style.name} — ${ds.style.keywords || ds.style.type}
${ds.style.bestFor ? `Best For: ${ds.style.bestFor}` : ''}
${ds.style.performance ? `Performance: ${ds.style.performance} | Accessibility: ${ds.style.accessibility}` : ''}

ТИПОГРАФИКА:
- Heading: ${ds.typography.heading}
- Body: ${ds.typography.body}
- Mood: ${ds.typography.mood}
${ds.typography.cssImport ? `- CSS Import: ${ds.typography.cssImport}` : ''}
- Подключи через Google Fonts CDN с display=swap + preconnect
- Используй typography структурно: контраст размеров, ритм, иерархия через scale

ЦВЕТА (определи через CSS custom properties :root):
- Primary: ${ds.colors.primary}
- Secondary: ${ds.colors.secondary}
- CTA: ${ds.colors.cta}
- Background: ${ds.colors.background}
- Text: ${ds.colors.text}
${ds.colors.notes ? `- Notes: ${ds.colors.notes}` : ''}

ПАТТЕРН СТРАНИЦЫ: ${ds.pattern.name}
- Секции: ${ds.pattern.sections}
- CTA: ${ds.pattern.ctaPlacement}
${ds.pattern.conversion ? `- Conversion: ${ds.pattern.conversion}` : ''}
${ds.pattern.colorStrategy ? `- Color Strategy: ${ds.pattern.colorStrategy}` : ''}

MOTION И ЭФФЕКТЫ:
${ds.keyEffects || '- Subtle hover transitions (150-300ms)'}
${ds.style.effects && ds.style.effects !== ds.keyEffects ? `- ${ds.style.effects}` : ''}

АНТИ-ПАТТЕРНЫ (= ПРОВАЛ):
${antiLines}
- Дефолтные Tailwind/ShadCN layouts
- Системные шрифты (Inter, Roboto, Arial, system-ui)
- Если дизайн можно спутать с шаблоном — переделай

ДОПОЛНИТЕЛЬНЫЕ ОБЯЗАТЕЛЬНЫЕ ПРАВИЛА:
- ЗАПРЕЩЕНЫ: emojis как иконки — использовать SVG (Heroicons/Lucide)
- cursor-pointer на всех кликабельных элементах
- Hover transitions: 150-300ms
- prefers-reduced-motion: reduce — отключать анимации
- Контраст текста: минимум 4.5:1 (AA)
- Focus-visible стили на интерактивных элементах
- Responsive: 375px, 768px, 1024px, 1440px
- Шрифты через Google Fonts CDN с display=swap + preconnect
- Все цвета через CSS custom properties (:root)`;
    }

    const DEFAULT_DESIGN_SYSTEM = `———————————————————————————
ДИЗАЙН-СИСТЕМА (ОБЯЗАТЕЛЬНАЯ К ИСПОЛНЕНИЮ)
———————————————————————————

AESTHETIC DIRECTION: Editorial / Magazine — строгий, экспертный, с характером.
Если ниша технологическая — допустим сдвиг к Industrial / Utilitarian.

ТИПОГРАФИКА (КРИТИЧЕСКИ ВАЖНО):
- ЗАПРЕЩЕНЫ: Inter, Roboto, Arial, system-ui, sans-serif по умолчанию
- Выбери 1 expressive display шрифт (например: Playfair Display, Space Grotesk, Instrument Serif, Clash Display, Syne, DM Serif Display) для заголовков
- Выбери 1 restrained body шрифт (например: Source Serif 4, Literata, IBM Plex Sans, Outfit, Satoshi) для текста
- Подключи через Google Fonts CDN
- Используй typography структурно: контраст размеров, ритм, иерархия через scale

ЦВЕТА:
- Определи все цвета через CSS custom properties (:root)
- Схема: 1 доминантный фон + 1 акцент + 1 нейтральная система (светлый/тёмный)
- ЗАПРЕЩЕНЫ: purple-on-white SaaS градиенты, равномерно-сбалансированные палитры
- Цвета должны передавать настроение: доверие, экспертность, серьёзность

ПРОСТРАНСТВО И КОМПОНОВКА:
- Ломай сетку намеренно: используй асимметрию, overlap элементов, controlled density
- Негативное пространство — это дизайн-элемент, не пустота
- ЗАПРЕЩЕНЫ: симметричные предсказуемые секции, дефолтные grid-layouts
- TOP-5 карточки должны визуально отличаться друг от друга позиционированием

MOTION И ЭФФЕКТЫ:
- Анимации: purposeful, sparse, high-impact
- 1 сильная entrance-анимация для hero-блока
- Несколько meaningful hover-состояний для карточек и CTA
- ЗАПРЕЩЕНЫ: decorative micro-motion spam, бесконечные пульсации
- CSS-first анимации. JS-анимации только если CSS недостаточно

ТЕКСТУРА И REFINEMENT:
- Используй минимум 2 из: noise/grain overlay, gradient mesh, layered translucency, custom borders/dividers, shadows с narrative intent
- Тени — не box-shadow по умолчанию, а с конкретным смыслом (глубина карточки, выделение лидера)

DIFFERENTIATION ANCHOR:
- Если убрать логотип и текст — дизайн всё равно должен быть узнаваемым
- Должен быть хотя бы 1 элемент, который запомнится через 24 часа

АНТИ-ПАТТЕРНЫ (= ПРОВАЛ):
- Дефолтные Tailwind/ShadCN layouts
- Системные шрифты
- Purple-on-white градиенты
- Симметричные секции без характера
- Если дизайн можно спутать с шаблоном — переделай

ДОПОЛНИТЕЛЬНЫЕ ОБЯЗАТЕЛЬНЫЕ ПРАВИЛА:
- ЗАПРЕЩЕНЫ: emojis как иконки — использовать SVG (Heroicons/Lucide)
- cursor-pointer на всех кликабельных элементах
- Hover transitions: 150-300ms
- prefers-reduced-motion: reduce — отключать анимации
- Контраст текста: минимум 4.5:1 (AA)
- Focus-visible стили на интерактивных элементах
- Responsive: 375px, 768px, 1024px, 1440px
- Шрифты через Google Fonts CDN с display=swap + preconnect
- Все цвета через CSS custom properties (:root)`;

    // === Pipeline Steps Definition ===
    const PIPELINE_STEPS = [
      { id: 'step_1_2', label: 'Списки + критерии' },
      { id: 'step_3', label: 'Дедупликация Grok' },
      { id: 'step_4', label: 'Аудитории Grok' },
      { id: 'step_design', label: 'Дизайн-система' },
      { id: 'step_5', label: 'XML-компилятор' },
      { id: 'step_6', label: 'Генерация сайта' },
      { id: 'step_7', label: 'Поиск рейтингов' },
      { id: 'step_8_web', label: 'Скачивание рейтингов' },
    ];

    function getStepState(stepId, currentStep, projectStatus) {
      const stepOrder = PIPELINE_STEPS.map(s => s.id);
      const currentIdx = stepOrder.indexOf(currentStep);
      const stepIdx = stepOrder.indexOf(stepId);
      if (projectStatus === 'generated' || projectStatus === 'filled' || projectStatus === 'edited') return 'done';
      if (currentIdx < 0) return stepIdx === 0 ? 'pending' : 'pending';
      if (stepIdx < currentIdx) return 'done';
      if (stepIdx === currentIdx) return 'done';
      return 'pending';
    }

    function renderTimeline(currentStep, projectStatus) {
      const icons = { pending: '⬚', done: '✅', running: '⏳', error: '❌' };
      return PIPELINE_STEPS.map((step, i) => {
        const state = getStepState(step.id, currentStep, projectStatus);
        return `${i > 0 ? '<span class="pipeline-arrow">→</span>' : ''}<div class="pipeline-step ${state}" id="timeline-${step.id}">${icons[state]} ${step.label}</div>`;
      }).join('');
    }

    function updateTimelineStep(stepId, state) {
      const icons = { pending: '⬚', done: '✅', running: '⏳', error: '❌' };
      const step = PIPELINE_STEPS.find(s => s.id === stepId);
      const el = document.getElementById(`timeline-${stepId}`);
      if (el && step) {
        el.className = `pipeline-step ${state}`;
        el.textContent = `${icons[state]} ${step.label}`;
      }
    }

    // === Project View ===
    function renderProject(id) {
      const projects = getProjects();
      const project = projects.find(p => p.id === id);
      const container = document.getElementById('screen-project');

      if (!project) {
        container.innerHTML = `
          <div style="text-align:center; padding:80px 20px;">
            <h2 style="color:#f85149; margin-bottom:16px;">Проект не найден</h2>
            <p style="color:#8b949e; margin-bottom:20px;">Проект с этим ID не существует или был удалён.</p>
            <button onclick="location.hash='#/'">Вернуться к проектам</button>
          </div>
        `;
        return;
      }

      currentProjectId = project.id;
      const hasHtml = !!project.html_content;
      const nicheGeo = project.geo ? `${escHtml(project.niche)} в ${escHtml(project.geo)}` : escHtml(project.niche);

      container.innerHTML = `
        <div class="project-header">
          <h1>${nicheGeo}</h1>
          <div class="project-header-meta">
            <span class="pc-status ${project.status}">${STATUS_LABELS[project.status] || project.status}</span>
            ${project.query_lang ? `<span>·</span><span>Запросы: ${escHtml(project.query_lang)}</span>` : ''}
            ${project.site_lang ? `<span>·</span><span>Сайт: ${escHtml(project.site_lang)}</span>` : ''}
            ${project.geo_request ? `<span>·</span><span>Гео запроса: ${escHtml(project.geo_request)}</span>` : ''}
            ${project.injection_name ? `<span>·</span><span>Инъекция: ${escHtml(project.injection_name)}</span>` : ''}
          </div>
        </div>

        <div class="pipeline-timeline" id="pipeline-timeline">
          ${renderTimeline(project.meta?.currentStep, project.status)}
        </div>

        <div id="project-resume-bar"></div>

        <div class="project-pipeline-results" id="pipeline-results">
          <div class="results" id="results"></div>

          <div id="grok-section" style="display:none; margin-top: 24px;">
            <div class="result-card" id="grok-card">
              <div class="result-header">
                <span class="model-badge" style="background:#ef4444;">Grok</span>
                <span class="model-name">Дедупликация критериев</span>
              </div>
              <div class="chat-messages" id="grok-messages"></div>
            </div>
          </div>

          <div id="audience-section" style="display:none; margin-top: 24px;">
            <div class="result-card" id="audience-card">
              <div class="result-header">
                <span class="model-badge" style="background:#ef4444;">Grok</span>
                <span class="model-name">Аудитории и боли ЦА</span>
              </div>
              <div class="chat-messages" id="audience-messages"></div>
            </div>
          </div>

          <div id="design-section" style="display:none; margin-top: 24px;">
            <div class="result-card">
              <div class="result-header">
                <span class="model-badge" style="background:#8b5cf6;">BM25</span>
                <span class="model-name">Дизайн-система под нишу</span>
              </div>
              <div class="chat-messages" id="design-messages" style="max-height:none;"></div>
            </div>
          </div>

          <div id="compiler-section" style="display:none; margin-top: 24px;">
            <div class="result-card" id="compiler-card">
              <div class="result-header">
                <span class="model-badge badge-claude">Claude</span>
                <span class="model-name">XML-структура критериев</span>
              </div>
              <div class="chat-messages" id="compiler-messages" style="max-height:none;"></div>
            </div>
          </div>

          <div id="canvas-section" style="display:none; margin-top: 24px;">
            <div class="result-card" id="canvas-card">
              <div class="result-header">
                <span class="model-badge badge-claude">Claude</span>
                <span class="model-name">Готовый сайт (HTML)</span>
              </div>
              <div class="canvas-toolbar" id="canvas-toolbar" style="display:none;">
                <div class="canvas-tabs">
                  <button class="canvas-tab active" onclick="switchCanvasTab('preview')">Превью</button>
                  <button class="canvas-tab" onclick="switchCanvasTab('code')">Код</button>
                </div>
                <button class="copy-btn" onclick="navigator.clipboard.writeText(canvasRawHtml).then(()=>{this.textContent='Скопировано!';setTimeout(()=>this.textContent='Копировать HTML',1500)})">Копировать HTML</button>
              </div>
              <div class="editor-toolbar" id="editor-toolbar" style="display:none;">
                <div style="flex:1;"></div>
                <button class="editor-btn" id="seo-panel-toggle" onclick="toggleSeoPanel()">SEO и счётчики</button>
                <button class="editor-btn editor-btn-primary" onclick="openInEditor()">Открыть в редакторе</button>
                <button class="editor-btn editor-btn-primary" id="download-html-btn" onclick="downloadHtml()">Скачать HTML</button>
              </div>
              <div id="canvas-loading" class="loading" style="display:none;"><div class="spinner"></div>Claude генерирует сайт...</div>
              <div id="canvas-preview" style="display:none;">
                <iframe id="canvas-iframe" class="canvas-frame" sandbox="allow-scripts allow-same-origin"></iframe>
              </div>
              <div id="canvas-code-view" style="display:none;">
                <pre class="canvas-code"><code id="canvas-code-content"></code></pre>
              </div>
            </div>

            <div class="seo-panel" id="seo-panel">
              <h3>SEO и счётчики</h3>
              <div class="seo-grid">
                <div class="seo-field">
                  <label for="counterYandex">Яндекс.Метрика</label>
                  <textarea id="counterYandex" placeholder="Вставьте полный код счётчика"></textarea>
                </div>
                <div class="seo-field">
                  <label for="counterGoogle">Google Analytics / GTM</label>
                  <textarea id="counterGoogle" placeholder="Вставьте код GA или GTM"></textarea>
                </div>
                <div class="seo-field">
                  <label for="metaYandex">Яндекс.Вебмастер</label>
                  <input type="text" id="metaYandex" placeholder="yandex-verification значение">
                </div>
                <div class="seo-field">
                  <label for="metaGoogle">Google Search Console</label>
                  <input type="text" id="metaGoogle" placeholder="google-site-verification значение">
                </div>
                <div class="seo-field">
                  <label for="metaTitle">Title</label>
                  <input type="text" id="metaTitle" placeholder="Заголовок страницы">
                </div>
                <div class="seo-field">
                  <label for="metaDesc">Description</label>
                  <textarea id="metaDesc" placeholder="Описание страницы (до 160 символов)"></textarea>
                </div>
                <div class="seo-field">
                  <label for="metaKeywords">Keywords</label>
                  <input type="text" id="metaKeywords" placeholder="Ключевые слова через запятую">
                </div>
                <div class="seo-field">
                  <label for="metaOgImage">OG Image URL</label>
                  <input type="text" id="metaOgImage" placeholder="https://example.com/image.jpg">
                </div>
              </div>
              <div class="seo-actions">
                <button class="editor-btn editor-btn-primary" onclick="applySeoCounters()">Применить</button>
              </div>
            </div>
          </div>

          <div id="ratings-section" style="display:none; margin-top: 24px;">
            <div class="result-card" id="ratings-card">
              <div class="result-header">
                <span class="model-badge" style="background:#20b2aa;">Perplexity</span>
                <span class="model-name">Поиск рейтинговых сайтов</span>
              </div>
              <div style="padding: 20px;">
                <div id="ratings-loading" class="loading" style="display:none;"><div class="spinner"></div>Perplexity ищет рейтинги...</div>
                <div class="download-progress" id="ratings-progress"></div>
                <div class="companies-grid" id="ratings-grid"></div>
                <div id="rating-preview-wrap" style="display:none; margin-top: 16px;">
                  <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
                    <span id="rating-preview-title" style="font-size:14px; color:#58a6ff; font-weight:600;"></span>
                    <button class="copy-btn" onclick="document.getElementById('rating-preview-wrap').style.display='none'">Закрыть</button>
                  </div>
                  <iframe id="rating-preview-iframe" class="company-preview-frame" sandbox="allow-scripts allow-same-origin"></iframe>
                </div>
              </div>
            </div>
          </div>

          <div id="fill-section-wrap" style="display:none; margin-top: 24px;">
            <div class="result-card">
              <div style="padding: 20px;">
                <div class="fill-section">
                  <label style="font-size:13px; color:#8b949e; font-weight:500;">Данные вашей компании (она станет #1 в рейтинге)</label>
                  <textarea id="fill-company-data" placeholder="Название компании, описание услуг, преимущества, цены, отзывы клиентов..."></textarea>
                  <button id="fill-btn" onclick="fillTemplate()" disabled>Наполнить контентом</button>
                </div>
                <div id="fill-loading" class="loading" style="display:none;">
                  <div class="spinner"></div>Claude наполняет сайт реальными данными...
                </div>
              </div>
            </div>
          </div>
        </div>

        <div class="project-actions" style="margin-top:24px;">
          <button onclick="duplicateProject('${project.id}'); location.hash='#/';">Дублировать</button>
          <button onclick="deleteProject('${project.id}')" style="color:#f85149;">Удалить</button>
        </div>

        <details class="project-meta-section">
          <summary>Метаданные проекта ▾</summary>
          <div class="project-meta-content">
            <pre style="white-space:pre-wrap; word-break:break-all; font-size:12px; color:#8b949e;">ID: ${project.id}
Ниша: ${project.niche}
Гео: ${project.geo || '—'}
Язык запросов: ${project.query_lang || 'Русский'}
Язык сайта: ${project.site_lang || 'Русский'}
Статус: ${project.status}
Шаг пайплайна: ${project.meta?.currentStep || '—'}
Компания: ${project.injection_name || '—'}
Размер HTML: ${project.html_content ? (project.html_content.length / 1024).toFixed(1) + ' KB' : '—'}</pre>
          </div>
        </details>
      `;

      // Restore state from project meta and render existing results
      restoreProjectState(project);

      // Auto-start or show resume button
      if (project.status === 'in_progress' && !project.meta?.currentStep) {
        setTimeout(() => runPipeline(project.id), 100);
      } else if (project.status === 'in_progress' && project.meta?.currentStep) {
        const stepLabels = Object.fromEntries(PIPELINE_STEPS.map(s => [s.id, s.label]));
        const resumeBar = document.getElementById('project-resume-bar');
        resumeBar.innerHTML = `
          <div class="project-resume-bar">
            <span style="flex:1;">⏸ Пайплайн остановлен на шаге: <strong>${stepLabels[project.meta.currentStep] || project.meta.currentStep}</strong></span>
            <button onclick="runPipeline('${project.id}', '${getNextStep(project.meta.currentStep)}')" style="background:#238636; border-color:#238636; color:#fff;">Продолжить</button>
            <button onclick="runPipeline('${project.id}')" style="background:#1f6feb; border-color:#1f6feb; color:#fff;">Перезапустить</button>
          </div>
        `;
      }
    }

    function getNextStep(currentStep) {
      const stepOrder = PIPELINE_STEPS.map(s => s.id);
      const idx = stepOrder.indexOf(currentStep);
      if (idx < 0 || idx >= stepOrder.length - 1) return null;
      return stepOrder[idx + 1];
    }

    function restoreProjectState(project) {
      // Restore global vars from project meta
      if (project.meta) {
        if (project.meta.conversations) Object.assign(conversations, project.meta.conversations);
        if (project.meta.compilerRawXml) compilerRawXml = project.meta.compilerRawXml;
        if (project.meta.grokCriteriaRaw) {
          // Show grok section with saved content
          const grokSection = document.getElementById('grok-section');
          const grokMsgs = document.getElementById('grok-messages');
          if (grokSection && grokMsgs && project.meta.grokCriteriaHtml) {
            grokSection.style.display = 'block';
            grokMsgs.innerHTML = project.meta.grokCriteriaHtml;
          }
        }
        if (project.meta.grokAudienceRaw) {
          const audSection = document.getElementById('audience-section');
          const audMsgs = document.getElementById('audience-messages');
          if (audSection && audMsgs && project.meta.audienceHtml) {
            audSection.style.display = 'block';
            audMsgs.innerHTML = project.meta.audienceHtml;
          }
        }
        if (project.meta.designSystemRaw) {
          const designSection = document.getElementById('design-section');
          const designMsgs = document.getElementById('design-messages');
          if (designSection && designMsgs) {
            designSection.style.display = 'block';
            designMsgs.innerHTML = `
              <div class="chat-msg chat-msg-assistant" style="padding:20px">
                <div class="chat-msg-label">Design System (BM25)</div>
                <div style="white-space:pre-wrap; font-size:12px; color:#8b949e">${project.meta.designSystemRaw.replace(/</g, '&lt;')}</div>
              </div>`;
          }
        }
        if (project.meta.compilerRawXml) {
          const compSection = document.getElementById('compiler-section');
          const compMsgs = document.getElementById('compiler-messages');
          if (compSection && compMsgs && project.meta.compilerHtml) {
            compSection.style.display = 'block';
            compMsgs.innerHTML = project.meta.compilerHtml;
          }
        }
        if (project.meta.extractedRatings) {
          extractedRatings = project.meta.extractedRatings;
          if (project.meta.downloadedRatings) downloadedRatings = project.meta.downloadedRatings;
          const ratingsSection = document.getElementById('ratings-section');
          if (ratingsSection && extractedRatings.length > 0) {
            ratingsSection.style.display = 'block';
            renderRatingsGrid();
          }
        }
        // Restore model cards
        if (project.meta.conversations && project.meta.resultsHtml) {
          const resultsDiv = document.getElementById('results');
          if (resultsDiv) resultsDiv.innerHTML = project.meta.resultsHtml;
        }
      }

      // Restore HTML preview
      if (project.html_content) {
        canvasRawHtml = project.html_content;
        const canvasSection = document.getElementById('canvas-section');
        if (canvasSection) {
          canvasSection.style.display = 'block';
          document.getElementById('canvas-toolbar').style.display = 'flex';
          document.getElementById('editor-toolbar').style.display = 'flex';
          document.getElementById('canvas-preview').style.display = 'block';
          const iframe = document.getElementById('canvas-iframe');
          if (iframe) setTimeout(() => { iframe.srcdoc = canvasRawHtml; }, 0);
          const codeContent = document.getElementById('canvas-code-content');
          if (codeContent) codeContent.textContent = canvasRawHtml;
        }

        // Show fill section
        const fillWrap = document.getElementById('fill-section-wrap');
        if (fillWrap) {
          fillWrap.style.display = 'block';
          document.getElementById('fill-btn').disabled = false;
          // Pre-fill company data
          const fillData = document.getElementById('fill-company-data');
          if (fillData && project.injection_info) fillData.value = project.injection_info;
        }

        // Restore SEO fields
        if (project.seo_block) {
          try {
            const seoData = JSON.parse(project.seo_block);
            ['counterYandex','counterGoogle','metaYandex','metaGoogle','metaTitle','metaDesc','metaKeywords','metaOgImage'].forEach(f => {
              const el = document.getElementById(f);
              if (el && seoData[f]) el.value = seoData[f];
            });
          } catch(e) {}
        }
      }
    }

    // === Start Project (from generator form) ===
    function startProject() {
      const apiKey = document.getElementById("apiKey").value.trim();
      const niche = document.getElementById("niche").value.trim();
      if (!apiKey) return alert("Введите API-ключ OpenRouter");
      if (!niche) return alert("Введите название ниши");
      localStorage.setItem("openrouter_key", apiKey);
      const projectId = createProject();
      location.hash = '#/project/' + projectId;
    }

    // Project view actions
    function projectOpenInEditor(id) {
      const projects = getProjects();
      const project = projects.find(p => p.id === id);
      if (!project || !project.html_content) return showNotification('Нет HTML для редактирования', true);
      currentProjectId = project.id;
      canvasRawHtml = project.html_content;
      openInEditor();
    }

    function projectDownloadHtml(id) {
      const projects = getProjects();
      const project = projects.find(p => p.id === id);
      if (!project || !project.html_content) return showNotification('Нет HTML для скачивания', true);

      const niche = project.niche || 'site';
      const dateStr = new Date().toISOString().slice(0, 10);
      const filename = `rating-${niche.replace(/[^a-zA-Zа-яА-Я0-9]/g, '_')}-${dateStr}.html`;
      const blob = new Blob([project.html_content], { type: 'text/html; charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
    }

    // loadProjects() — deprecated
    function loadProjects() {}

    function escHtml(str) {
      const d = document.createElement('div');
      d.textContent = str;
      return d.innerHTML;
    }

    function createProject() {
      const niche = document.getElementById('niche').value.trim();
      const geo = document.getElementById('geo').value.trim() || null;
      const geoRequest = document.getElementById('geoRequest').value.trim() || null;
      const queryLang = document.getElementById('queryLang').value;
      const siteLang = document.getElementById('siteLang').value;
      const userCompanyData = document.getElementById('user-company-data')?.value.trim() || '';

      let injectionName = null, injectionUrl = null, injectionInfo = null;
      if (userCompanyData) {
        injectionInfo = userCompanyData;
        const lines = userCompanyData.split('\n');
        if (lines[0]) injectionName = lines[0].trim();
        const urlMatch = userCompanyData.match(/https?:\/\/[^\s]+/);
        if (urlMatch) injectionUrl = urlMatch[0];
      }

      const id = crypto.randomUUID();
      const project = {
        id, created_at: new Date().toISOString(), updated_at: new Date().toISOString(),
        niche, geo, geo_request: geoRequest, query_lang: queryLang, site_lang: siteLang,
        injection_name: injectionName, injection_url: injectionUrl, injection_info: injectionInfo,
        status: 'in_progress', html_content: null, seo_block: null, counters_block: null, meta: {}
      };

      const projects = getProjects();
      projects.unshift(project);
      saveProjects(projects);
      currentProjectId = id;
      return id;
    }

    function updateProjectMeta(meta) {
      if (!currentProjectId) return;
      const projects = getProjects();
      const p = projects.find(p => p.id === currentProjectId);
      if (!p) return;
      p.meta = { ...p.meta, ...meta };
      p.updated_at = new Date().toISOString();
      saveProjects(projects);
    }

    function updateProjectStatus(status, htmlContent) {
      if (!currentProjectId) return;
      const projects = getProjects();
      const p = projects.find(p => p.id === currentProjectId);
      if (!p) return;
      p.status = status;
      p.updated_at = new Date().toISOString();
      if (htmlContent !== undefined) p.html_content = htmlContent;
      saveProjects(projects);
    }

    function updateProjectHtml(htmlContent, seoBlock, countersBlock) {
      if (!currentProjectId) return;
      const projects = getProjects();
      const p = projects.find(p => p.id === currentProjectId);
      if (!p) return;
      p.html_content = htmlContent;
      p.updated_at = new Date().toISOString();
      if (seoBlock !== undefined) p.seo_block = seoBlock;
      if (countersBlock !== undefined) p.counters_block = countersBlock;
      saveProjects(projects);
    }

    function openProject(id) {
      location.hash = '#/project/' + id;
    }

    function duplicateProject(id) {
      const projects = getProjects();
      const orig = projects.find(p => p.id === id);
      if (!orig) return;

      const copy = JSON.parse(JSON.stringify(orig));
      copy.id = crypto.randomUUID();
      copy.created_at = new Date().toISOString();
      copy.updated_at = new Date().toISOString();
      copy.niche = copy.niche + ' (копия)';
      copy.status = 'in_progress';

      projects.unshift(copy);
      saveProjects(projects);

      const hash = location.hash || '#/';
      if (hash === '#/' || hash === '#') renderDashboard();
      showNotification('Проект дублирован');
    }

    function deleteProject(id) {
      if (!confirm('Удалить проект? Это действие необратимо.')) return;

      let projects = getProjects();
      projects = projects.filter(p => p.id !== id);
      saveProjects(projects);

      if (currentProjectId === id) currentProjectId = null;

      const hash = location.hash || '#/';
      if (hash === '#/' || hash === '#') renderDashboard();
      if (hash === `#/project/${id}`) location.hash = '#/';
      showNotification('Проект удалён');
    }

    const MODELS = [
      { id: "openai/gpt-5", name: "ChatGPT (GPT-5)" },
      { id: "google/gemini-3-pro-preview", name: "Gemini 3 Pro" },
      { id: "anthropic/claude-sonnet-4.5", name: "Claude (Sonnet 4.5)" },
    ];

    // Conversation history per model: { [modelId]: [{role, content}] }
    const conversations = {};

    // Direct OpenRouter call (no backend needed)
    async function callModel(modelId, messages, apiKey) {
      const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${apiKey}`,
        },
        body: JSON.stringify({ model: modelId, messages }),
      });

      if (!response.ok) {
        const err = await response.text();
        return { error: `Ошибка API: ${response.status} — ${err}` };
      }

      const data = await response.json();
      const content = data.choices?.[0]?.message?.content || "Пустой ответ";
      return { content };
    }

    function mdTableToHtml(text) {
      const lines = text.split("\n").map(l => l.trim()).filter(l => l.startsWith("|"));
      if (lines.length < 2) return null;

      const parseRow = line => line.split("|").slice(1, -1).map(c => c.trim());

      const headers = parseRow(lines[0]);
      // skip separator line (line with ---)
      const startIdx = lines[1].includes("---") ? 2 : 1;
      const rows = lines.slice(startIdx).map(parseRow);

      let html = "<table><thead><tr>";
      for (const h of headers) html += `<th>${h}</th>`;
      html += "</tr></thead><tbody>";
      for (const row of rows) {
        html += "<tr>";
        for (const cell of row) html += `<td>${cell}</td>`;
        html += "</tr>";
      }
      html += "</tbody></table>";
      return html;
    }

    // Parse audience response: always produce 2-column table + portraits block
    function parseAudienceResponse(text) {
      const lines = text.split("\n").map(l => l.trim()).filter(l => l.startsWith("|"));
      if (lines.length < 3) return null;

      const parseRow = line => line.split("|").slice(1, -1).map(c => c.trim());
      const headers = parseRow(lines[0]);
      const startIdx = lines[1].includes("---") ? 2 : 1;
      const dataRows = lines.slice(startIdx).map(parseRow);

      const colCount = headers.length;

      // Determine which columns are ЦА and Боль/Интент
      // If 3+ columns: first = ЦА, last = Боль, middle = Портрет
      const caIdx = 0;
      const painIdx = colCount - 1;
      const portraitIdx = colCount >= 3 ? 1 : -1;

      // Build 2-column table
      let tableHtml = `<table><thead><tr><th>ЦА</th><th>Боль / Интент</th></tr></thead><tbody>`;
      const portraits = {};

      for (const row of dataRows) {
        const ca = row[caIdx] || "";
        const pain = row[painIdx] || "";
        tableHtml += `<tr><td>${ca}</td><td>${pain}</td></tr>`;

        // Collect unique portraits
        if (portraitIdx >= 0 && row[portraitIdx] && ca && !portraits[ca]) {
          portraits[ca] = row[portraitIdx];
        }
      }
      tableHtml += "</tbody></table>";

      // Build portraits HTML
      let portraitsHtml = "";
      const entries = Object.entries(portraits);
      if (entries.length > 0) {
        portraitsHtml = `<div style="margin-top:20px; padding-top:16px; border-top:1px solid #30363d;">
          <div style="font-size:12px; color:#58a6ff; font-weight:600; text-transform:uppercase; letter-spacing:0.5px; margin-bottom:12px;">Портреты ЦА</div>`;
        for (const [name, desc] of entries) {
          portraitsHtml += `<div style="margin-bottom:8px; font-size:14px; line-height:1.6;"><span style="color:#e1e4e8; font-weight:600;">${name}:</span> <span style="color:#8b949e;">${desc}</span></div>`;
        }
        portraitsHtml += "</div>";
      }

      return { tableHtml, portraitsHtml };
    }

    // XML syntax highlighter
    function highlightXml(text) {
      // Strip markdown code fences if present
      text = text.replace(/^```xml\s*\n?/i, '').replace(/\n?```\s*$/i, '').trim();
      return text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/&lt;(\/?[\w_]+)(.*?)&gt;/g, (match, tag, rest) => {
          // Highlight attributes inside tags
          const highlighted = rest.replace(/([\w_]+)=(&quot;|")(.*?)(&quot;|")/g,
            '<span class="xml-attr">$1</span>=<span class="xml-val">"$3"</span>');
          return `<span class="xml-tag">&lt;${tag}${highlighted}&gt;</span>`;
        });
    }

    let compilerRawXml = ""; // Store for copy button
    let canvasRawHtml = ""; // Store for copy button
    let extractedRatings = [];   // [{name, url, status, errorReason}]
    let downloadedRatings = {};  // {name: {html, text}}

    // Strip HTML to plain text for AI processing
    function extractText(html) {
      const doc = new DOMParser().parseFromString(html, 'text/html');
      doc.querySelectorAll('script, style, svg, noscript, link, meta, header, footer, nav, iframe').forEach(el => el.remove());
      let text = doc.body?.innerText || '';
      return text.replace(/\n{3,}/g, '\n\n').replace(/[ \t]+/g, ' ').trim();
    }

    // Render ratings grid
    function renderRatingsGrid() {
      const grid = document.getElementById('ratings-grid');
      if (!grid) return;

      const doneCount = extractedRatings.filter(c => c.status === 'done').length;
      const totalCount = extractedRatings.length;
      const errorCount = extractedRatings.filter(c => c.status === 'error').length;

      document.getElementById('ratings-progress').textContent =
        `Загружено рейтингов: ${doneCount} из ${totalCount}` + (errorCount > 0 ? ` (ошибок: ${errorCount})` : '');

      grid.innerHTML = extractedRatings.map((rating, idx) => {
        const tooltip = rating.status === 'error'
          ? `Ошибка: ${rating.errorReason || 'неизвестна'}\nURL: ${rating.url || '—'}`
          : (rating.url || 'URL не найден');
        return `
        <button class="company-btn status-${rating.status}"
                onclick="previewRatingSite(${idx})"
                title="${tooltip}">
          <span class="company-status-icon ${rating.status}"></span>
          <span style="flex:1; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${rating.name}</span>
          ${rating.status === 'loading' ? '<span class="spinner-small"></span>' : ''}
        </button>`;
      }).join('');
    }

    // Preview a downloaded rating site in iframe (or show error details)
    function previewRatingSite(idx) {
      const rating = extractedRatings[idx];
      if (!rating) return;

      if (rating.status === 'error') {
        alert(`Ошибка загрузки: ${rating.name}\nURL: ${rating.url || '—'}\nПричина: ${rating.errorReason || 'неизвестна'}`);
        return;
      }
      if (rating.status !== 'done') return;

      const wrap = document.getElementById('rating-preview-wrap');
      const iframe = document.getElementById('rating-preview-iframe');
      const title = document.getElementById('rating-preview-title');

      title.textContent = `${rating.name} — ${rating.url}`;
      iframe.srcdoc = downloadedRatings[rating.name]?.html || '<p>Нет данных</p>';
      wrap.style.display = 'block';
      wrap.scrollIntoView({ behavior: 'smooth' });
    }

    // CORS proxy list — tried in order, first success wins
    // Tested 2026-02-18: codetabs works reliably, allorigins/corsproxy.io are down
    function getProxies(url) {
      const encoded = encodeURIComponent(url);
      return [
        { name: 'codetabs',    url: `https://api.codetabs.com/v1/proxy?quest=${encoded}`, type: 'raw' },
        { name: 'allorigins',  url: `https://api.allorigins.win/get?url=${encoded}`, type: 'json', field: 'contents' },
        { name: 'corsproxy',   url: `https://corsproxy.io/?url=${encoded}`, type: 'raw' },
      ];
    }

    // Download a single site via CORS proxy (universal — works for companies & ratings)
    async function downloadSite(url, verbose) {
      const proxies = getProxies(url);
      const errors = [];

      for (const proxy of proxies) {
        try {
          const controller = new AbortController();
          const timeout = setTimeout(() => controller.abort(), 15000);
          const start = Date.now();

          const resp = await fetch(proxy.url, { signal: controller.signal });
          clearTimeout(timeout);
          const elapsed = Date.now() - start;

          if (!resp.ok) {
            errors.push({ proxy: proxy.name, error: `HTTP ${resp.status}`, ms: elapsed });
            continue;
          }

          let html;
          if (proxy.type === 'json') {
            const data = await resp.json();
            html = data[proxy.field];
          } else {
            html = await resp.text();
          }

          if (!html || html.length < 100) {
            errors.push({ proxy: proxy.name, error: `пустой/короткий ответ (${(html||'').length} байт)`, ms: elapsed });
            continue;
          }

          const text = extractText(html).substring(0, 8000);
          if (verbose) return { ok: true, html, text, proxy: proxy.name, size: html.length, ms: elapsed, errors };
          return { ok: true, html, text };
        } catch (e) {
          const reason = e.name === 'AbortError' ? 'таймаут 15с' : e.message;
          errors.push({ proxy: proxy.name, error: reason, ms: null });
          continue;
        }
      }

      const errorStr = errors.map(e => `${e.proxy}: ${e.error}${e.ms ? ` (${e.ms}мс)` : ''}`).join(' → ');
      return { ok: false, error: errorStr || 'Все прокси недоступны', errors };
    }

    // Test download from the form
    async function testDownload() {
      const url = document.getElementById('testUrl').value.trim();
      const resultEl = document.getElementById('testResult');
      if (!url) { resultEl.textContent = 'Введите URL'; return; }

      resultEl.textContent = 'Загрузка...';
      resultEl.style.color = '#d29922';

      const result = await downloadSite(url, true);

      if (result.ok) {
        resultEl.style.color = '#238636';
        resultEl.textContent = `✅ Успех через ${result.proxy} (${result.ms}мс)\nРазмер HTML: ${(result.size / 1024).toFixed(1)} KB | Текст: ${result.text.length} символов`;
        if (result.errors.length > 0) {
          resultEl.textContent += `\n⚠️ Другие прокси:\n${result.errors.map(e => `  ✗ ${e.proxy}: ${e.error}${e.ms ? ` (${e.ms}мс)` : ''}`).join('\n')}`;
        }
      } else {
        resultEl.style.color = '#f85149';
        resultEl.textContent = `❌ Все прокси не сработали:\n${result.errors.map(e => `  ✗ ${e.proxy}: ${e.error}${e.ms ? ` (${e.ms}мс)` : ''}`).join('\n')}`;
      }
    }

    // Download a single rating site
    async function downloadRatingSite(rating, index) {
      if (!rating.url) {
        extractedRatings[index].status = 'error';
        extractedRatings[index].errorReason = 'URL не найден';
        renderRatingsGrid();
        return;
      }

      extractedRatings[index].status = 'loading';
      renderRatingsGrid();

      const result = await downloadSite(rating.url);
      if (result.ok) {
        downloadedRatings[rating.name] = { html: result.html, text: result.text };
        extractedRatings[index].status = 'done';
      } else {
        extractedRatings[index].status = 'error';
        extractedRatings[index].errorReason = result.error;
      }
      renderRatingsGrid();
    }

    // Step 7b: Fill template with real data from downloaded sites + user data
    async function fillTemplate() {
      const apiKey = localStorage.getItem("openrouter_key") || '';
      const project = currentProjectId ? getProjects().find(p => p.id === currentProjectId) : null;
      const userCompanyData = document.getElementById("fill-company-data")?.value?.trim() || project?.injection_info || '';
      const niche = project?.niche || '';
      const fillBtn = document.getElementById("fill-btn");
      const fillLoading = document.getElementById("fill-loading");

      if (!apiKey) return alert("Нет API-ключа OpenRouter. Создайте новый проект.");
      if (!canvasRawHtml) return alert("Сначала сгенерируйте сайт (шаги 1-6)");

      fillBtn.disabled = true;
      fillLoading.style.display = "flex";

      // Build ratings data blocks (priority source — structured reviews)
      const MAX_RATINGS_CHARS = 60000;
      let ratingsChars = 0;
      const ratingDataBlocks = extractedRatings
        .filter(r => r.status === 'done' && downloadedRatings[r.name])
        .map(r => {
          const text = downloadedRatings[r.name].text.substring(0, 8000);
          ratingsChars += text.length;
          if (ratingsChars > MAX_RATINGS_CHARS) return null;
          return `=== ${r.name} (${r.url}) ===\n${text}`;
        })
        .filter(Boolean)
        .join("\n\n---\n\n");

      const fillSiteLang = project?.site_lang || 'Русский';
      const fillSiteLangStr = `Весь контент сайта на языке: ${fillSiteLang}`;

      // --- Защита PROTECTED блоков ---
      let savedSeoBlock = '';
      let savedCountersBlock = '';
      let cleanedCanvasHtml = canvasRawHtml;

      const seoMatch = cleanedCanvasHtml.match(/<!-- PROTECTED:SEO:START -->([\s\S]*?)<!-- PROTECTED:SEO:END -->/);
      if (seoMatch) {
        savedSeoBlock = seoMatch[1];
        cleanedCanvasHtml = cleanedCanvasHtml.replace(seoMatch[0], '<!-- PROTECTED:SEO:START --><!-- PROTECTED:SEO:END -->');
      }
      const countersMatch = cleanedCanvasHtml.match(/<!-- PROTECTED:COUNTERS:START -->([\s\S]*?)<!-- PROTECTED:COUNTERS:END -->/);
      if (countersMatch) {
        savedCountersBlock = countersMatch[1];
        cleanedCanvasHtml = cleanedCanvasHtml.replace(countersMatch[0], '<!-- PROTECTED:COUNTERS:START --><!-- PROTECTED:COUNTERS:END -->');
      }

      const fillPrompt = `ЯЗЫК САЙТА: ${fillSiteLangStr}

РОЛЬ: Ты — Senior SEO-копирайтер и веб-разработчик. Твоя задача — наполнить готовый HTML-шаблон рейтинга реальными данными компаний.

ВХОДНЫЕ ДАННЫЕ:

1. HTML-ШАБЛОН САЙТА:
<template>
${cleanedCanvasHtml}
</template>

2. ДАННЫЕ С РЕЙТИНГОВЫХ САЙТОВ (структурированные обзоры — ОСНОВНОЙ источник фактов):
<ratings_data>
${ratingDataBlocks || "(Рейтинговые сайты не были скачаны)"}
</ratings_data>

3. ДАННЫЕ КОМПАНИИ ПОЛЬЗОВАТЕЛЯ (ДОЛЖНА СТАТЬ #1 В РЕЙТИНГЕ):
<user_company>
${userCompanyData || "(Пользователь не предоставил данные своей компании)"}
</user_company>

4. XML-СТРУКТУРА КРИТЕРИЕВ:
<criteria>
${compilerRawXml}
</criteria>

ЗАДАЧА:
1. Используй данные рейтинговых сайтов (ratings_data) как ОСНОВНОЙ источник фактов: названия компаний, описания, цены, баллы, преимущества, недостатки.
2. Наполни HTML-шаблон реальными данными:
   - Замени placeholder-названия на реальные.
   - Замени placeholder-описания на реальные данные.
   - Заполни метрики на основе анализа данных.
   - Обнови баллы и рейтинги.
3. КРИТИЧЕСКИ ВАЖНО: Компания пользователя (из user_company) ДОЛЖНА быть на 1 месте с бейджем "Выбор редакции" и наивысшими баллами.
4. Сохрани всю структуру, стили, Schema.org разметку и JavaScript из шаблона.
5. ${fillSiteLangStr}.

СОХРАНЕНИЕ РАЗМЕТКИ БЛОКОВ:
Все атрибуты data-block-id, data-block-type, data-company-rank на элементах <section> и <tr> должны быть сохранены в неизменном виде. Не удалять, не менять нумерацию. Если добавляешь новые блоки — продолжай нумерацию data-block-id с максимального существующего +1.

ЗАЩИТНЫЕ МАРКЕРЫ:
Блоки между <!-- PROTECTED:SEO:START/END --> и <!-- PROTECTED:COUNTERS:START/END --> в <head> НЕ ТРОГАЙ. Не удаляй маркеры, не меняй содержимое между ними, не перемещай их.

SCHEMA.ORG: Не дублируй JSON-LD сущности. Question — только внутри FAQPage.mainEntity, не создавай отдельные JSON-LD блоки для Question. Person — один блок с @id, остальные ссылаются через @id.

ФОРМАТ: Выведи ТОЛЬКО полный HTML-код. Без пояснений, без markdown, без тройных бэктиков. Чистый HTML начиная с <!DOCTYPE html>.`;

      try {
        const fillData = await callModel("anthropic/claude-sonnet-4.5", [{ role: "user", content: fillPrompt }], apiKey);

        if (fillData.error) {
          fillLoading.innerHTML = `<div class="error-text" style="padding:20px;">[Ошибка] ${fillData.error}</div>`;
        } else {
          let filledHtml = fillData.content;
          filledHtml = filledHtml.replace(/^```html?\s*\n?/i, '').replace(/\n?```\s*$/i, '').trim();

          // --- Восстановление PROTECTED блоков ---
          if (savedSeoBlock) {
            if (filledHtml.includes('<!-- PROTECTED:SEO:START -->')) {
              filledHtml = filledHtml.replace(
                /<!-- PROTECTED:SEO:START -->[\s\S]*?<!-- PROTECTED:SEO:END -->/,
                `<!-- PROTECTED:SEO:START -->${savedSeoBlock}<!-- PROTECTED:SEO:END -->`
              );
            } else {
              filledHtml = filledHtml.replace('</head>', `<!-- PROTECTED:SEO:START -->${savedSeoBlock}<!-- PROTECTED:SEO:END -->\n</head>`);
            }
          }
          if (savedCountersBlock) {
            if (filledHtml.includes('<!-- PROTECTED:COUNTERS:START -->')) {
              filledHtml = filledHtml.replace(
                /<!-- PROTECTED:COUNTERS:START -->[\s\S]*?<!-- PROTECTED:COUNTERS:END -->/,
                `<!-- PROTECTED:COUNTERS:START -->${savedCountersBlock}<!-- PROTECTED:COUNTERS:END -->`
              );
            } else {
              filledHtml = filledHtml.replace('</head>', `<!-- PROTECTED:COUNTERS:START -->${savedCountersBlock}<!-- PROTECTED:COUNTERS:END -->\n</head>`);
            }
          }

          canvasRawHtml = filledHtml;

          const iframe = document.getElementById("canvas-iframe");
          iframe.srcdoc = filledHtml;

          const codeContent = document.getElementById("canvas-code-content");
          codeContent.textContent = filledHtml;

          fillLoading.style.display = "none";

          // Show editor toolbar + reset editor state
          document.getElementById("editor-toolbar").style.display = "flex";
          editorActive = false;
          historyStack = [];
          historyIndex = -1;

          document.getElementById("canvas-section").scrollIntoView({ behavior: "smooth" });
          updateProjectStatus('filled', canvasRawHtml);
        }
      } catch (err) {
        fillLoading.innerHTML = `<div class="error-text" style="padding:20px;">[Ошибка] ${err.message}</div>`;
      }

      fillBtn.disabled = false;
    }

    function switchCanvasTab(tab) {
      const previewEl = document.getElementById('canvas-preview');
      const codeEl = document.getElementById('canvas-code-view');
      const tabs = document.querySelectorAll('.canvas-tab');
      tabs.forEach(t => t.classList.remove('active'));
      if (tab === 'preview') {
        previewEl.style.display = 'block';
        codeEl.style.display = 'none';
        tabs[0].classList.add('active');
      } else {
        previewEl.style.display = 'none';
        codeEl.style.display = 'block';
        tabs[1].classList.add('active');
      }
    }

    // =============================================
    // Block Editor — state
    // =============================================
    let editorActive = false;
    let historyStack = [];
    let historyIndex = -1;
    const MAX_HISTORY = 20;
    let editorInjected = false;

    // =============================================
    // 3C — SEO Panel toggle & apply
    // =============================================
    function toggleSeoPanel() {
      const panel = document.getElementById('seo-panel');
      panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
    }

    function showNotification(text, isError) {
      const div = document.createElement('div');
      div.className = 'seo-notification';
      if (isError) div.style.background = '#da3633';
      div.textContent = text;
      document.body.appendChild(div);
      setTimeout(() => div.remove(), 2600);
    }

    function applySeoCounters() {
      const iframe = document.getElementById('canvas-iframe');
      const iDoc = iframe.contentDocument;
      if (!iDoc) return showNotification('Сначала сгенерируйте сайт', true);

      const metaTitle = document.getElementById('metaTitle').value.trim();
      const metaDesc = document.getElementById('metaDesc').value.trim();
      const metaKeywords = document.getElementById('metaKeywords').value.trim();
      const metaYandex = document.getElementById('metaYandex').value.trim();
      const metaGoogle = document.getElementById('metaGoogle').value.trim();
      const metaOgImage = document.getElementById('metaOgImage').value.trim();
      const counterYandex = document.getElementById('counterYandex').value.trim();
      const counterGoogle = document.getElementById('counterGoogle').value.trim();

      const head = iDoc.head;

      // --- SEO block ---
      let seoContent = '';
      if (metaTitle) seoContent += `<title>${metaTitle}</title>\n`;
      if (metaDesc) seoContent += `<meta name="description" content="${metaDesc}">\n`;
      if (metaKeywords) seoContent += `<meta name="keywords" content="${metaKeywords}">\n`;
      if (metaYandex) seoContent += `<meta name="yandex-verification" content="${metaYandex}">\n`;
      if (metaGoogle) seoContent += `<meta name="google-site-verification" content="${metaGoogle}">\n`;
      if (metaTitle) seoContent += `<meta property="og:title" content="${metaTitle}">\n`;
      if (metaDesc) seoContent += `<meta property="og:description" content="${metaDesc}">\n`;
      if (metaOgImage) seoContent += `<meta property="og:image" content="${metaOgImage}">\n`;
      seoContent += `<meta property="og:type" content="website">\n`;

      // --- Counters block ---
      let countersContent = '';
      if (counterYandex) countersContent += counterYandex + '\n';
      if (counterGoogle) countersContent += counterGoogle + '\n';

      // Update head innerHTML via string manipulation for reliability
      let headHtml = head.innerHTML;

      // Replace or insert SEO block
      const seoRe = /<!-- PROTECTED:SEO:START -->[\s\S]*?<!-- PROTECTED:SEO:END -->/;
      const seoBlock = `<!-- PROTECTED:SEO:START -->\n${seoContent}<!-- PROTECTED:SEO:END -->`;
      if (seoRe.test(headHtml)) {
        headHtml = headHtml.replace(seoRe, seoBlock);
      } else {
        headHtml += '\n' + seoBlock;
      }

      // Replace or insert Counters block
      const cntRe = /<!-- PROTECTED:COUNTERS:START -->[\s\S]*?<!-- PROTECTED:COUNTERS:END -->/;
      const cntBlock = `<!-- PROTECTED:COUNTERS:START -->\n${countersContent}<!-- PROTECTED:COUNTERS:END -->`;
      if (cntRe.test(headHtml)) {
        headHtml = headHtml.replace(cntRe, cntBlock);
      } else {
        headHtml += '\n' + cntBlock;
      }

      head.innerHTML = headHtml;
      syncCanvasRawHtml();

      // Save SEO data to project
      const seoData = {};
      ['counterYandex','counterGoogle','metaYandex','metaGoogle','metaTitle','metaDesc','metaKeywords','metaOgImage'].forEach(f => {
        const el = document.getElementById(f);
        if (el) seoData[f] = el.value;
      });
      if (currentProjectId) {
        const projects = getProjects();
        const p = projects.find(p => p.id === currentProjectId);
        if (p) { p.seo_block = JSON.stringify(seoData); p.updated_at = new Date().toISOString(); saveProjects(projects); }
      }

      showNotification('Счётчики и мета-теги применены');
    }

    // =============================================
    // 3B.6 — Autosave canvasRawHtml from iframe
    // =============================================
    function getActiveEditorDoc() {
      // If editor window is open, prefer it
      if (editorWindow && !editorWindow.closed && editorWindow.document?.body) {
        return editorWindow.document;
      }
      const iframe = document.getElementById('canvas-iframe');
      return iframe?.contentDocument || null;
    }

    function syncCanvasRawHtml() {
      if (editorWindow && !editorWindow.closed) {
        // Sync from editor window — get clean HTML without editor artifacts
        const doc = editorWindow.document;
        if (doc?.documentElement) {
          let html = '<!DOCTYPE html>' + doc.documentElement.outerHTML;
          // Clean editor artifacts
          html = html.replace(/<div id="__ew_toolbar__">[\s\S]*?<\/div>\s*/, '');
          html = html.replace(/<style id="__editor_style__">[\s\S]*?<\/style>/g, '');
          html = html.replace(/<style id="__editor_spin_style__">[\s\S]*?<\/style>/g, '');
          html = html.replace(/<style id="__ew_anim_style__">[\s\S]*?<\/style>/g, '');
          html = html.replace(/<div class="__editor_toolbar__">[\s\S]*?<\/div>/g, '');
          html = html.replace(/<div class="__editor_comment_popup__">[\s\S]*?<\/div>/g, '');
          html = html.replace(/<div class="__editor_loader__">[\s\S]*?<\/div>/g, '');
          html = html.replace(/<div id="__ew_seo_panel__">[\s\S]*?<\/div>\s*<\/div>/g, '');
          html = html.replace(/<div id="__ew_notification__">[\s\S]*?<\/div>/g, '');
          html = html.replace(/ ?class="__editor_hover__"/g, '');
          html = html.replace(/ ?class="__editor_collapsed__"/g, '');
          html = html.replace(/ style="position: relative;"/g, '');
          html = html.replace(/ style="padding-top: 50px;"/g, '');
          canvasRawHtml = html;
          editorWindowDirty = true;
        }
      } else {
        const iframe = document.getElementById('canvas-iframe');
        if (iframe?.contentDocument?.documentElement) {
          canvasRawHtml = '<!DOCTYPE html>' + iframe.contentDocument.documentElement.outerHTML;
        }
      }
      // Also update code view
      const codeContent = document.getElementById("canvas-code-content");
      if (codeContent) codeContent.textContent = canvasRawHtml;
      updateProjectHtml(canvasRawHtml);
    }

    // =============================================
    // 3B.5 — Undo / Redo
    // =============================================
    function pushSnapshot() {
      const doc = getActiveEditorDoc();
      const body = doc?.body;
      if (!body) return;

      // If we're in the middle of history, discard the forward part
      if (historyIndex < historyStack.length - 1) {
        historyStack = historyStack.slice(0, historyIndex + 1);
      }

      historyStack.push(body.innerHTML);

      if (historyStack.length > MAX_HISTORY) {
        historyStack.shift();
      }
      historyIndex = historyStack.length - 1;
      updateUndoRedoButtons();
    }

    function editorUndo() {
      if (historyIndex <= 0) return;
      historyIndex--;
      restoreSnapshot();
    }

    function editorRedo() {
      if (historyIndex >= historyStack.length - 1) return;
      historyIndex++;
      restoreSnapshot();
    }

    function restoreSnapshot() {
      const doc = getActiveEditorDoc();
      const body = doc?.body;
      if (!body || historyIndex < 0 || historyIndex >= historyStack.length) return;

      body.innerHTML = historyStack[historyIndex];
      // Restore padding-top if in editor window
      if (editorWindow && !editorWindow.closed && doc === editorWindow.document) {
        body.style.paddingTop = '50px';
      }
      syncCanvasRawHtml();
      updateUndoRedoButtons();
      // Re-inject editor event listeners after restoring
      if (editorActive) injectEditorListeners(doc);
    }

    function updateUndoRedoButtons() {
      document.getElementById('undo-btn').disabled = historyIndex <= 0;
      document.getElementById('redo-btn').disabled = historyIndex >= historyStack.length - 1;
    }

    // =============================================
    // 3B.1 — Editor mode toggle
    // =============================================
    function toggleEditorMode(on) {
      editorActive = on;
      const undoBtn = document.getElementById('undo-btn');
      const redoBtn = document.getElementById('redo-btn');

      undoBtn.style.display = on ? '' : 'none';
      redoBtn.style.display = on ? '' : 'none';

      const iDoc = getActiveEditorDoc();
      if (!iDoc) return;

      if (on) {
        // Take initial snapshot
        if (historyStack.length === 0) pushSnapshot();
        injectEditorListeners(iDoc);
      } else {
        removeEditorOverlays(iDoc);
      }
    }

    // =============================================
    // 3B.2 — Hover overlay + toolbar injection
    // =============================================
    function injectEditorListeners(iDoc) {
      // Remove previous injected style/listeners if any
      removeEditorOverlays(iDoc);

      // Inject overlay style
      const style = iDoc.createElement('style');
      style.id = '__editor_style__';
      style.textContent = `
        [data-block-id].__editor_hover__ {
          outline: 2px dashed #3b82f6 !important;
          outline-offset: 4px !important;
          position: relative;
        }
        .__editor_toolbar__ {
          position: absolute;
          top: 4px;
          right: 4px;
          z-index: 9999;
          display: flex;
          gap: 4px;
          background: #fff;
          border-radius: 8px;
          box-shadow: 0 2px 12px rgba(0,0,0,0.18);
          padding: 4px 6px;
          font-size: 13px;
        }
        .__editor_toolbar__ button {
          background: #f3f4f6;
          border: 1px solid #d1d5db;
          border-radius: 6px;
          padding: 4px 8px;
          cursor: pointer;
          font-size: 13px;
          line-height: 1;
        }
        .__editor_toolbar__ button:hover {
          background: #e5e7eb;
        }
        .__editor_comment_popup__ {
          position: absolute;
          top: 40px;
          right: 4px;
          z-index: 10000;
          background: #fff;
          border: 1px solid #d1d5db;
          border-radius: 8px;
          box-shadow: 0 4px 16px rgba(0,0,0,0.2);
          padding: 12px;
          width: 300px;
        }
        .__editor_comment_popup__ textarea {
          width: 100%;
          min-height: 80px;
          border: 1px solid #d1d5db;
          border-radius: 6px;
          padding: 8px;
          font-size: 13px;
          resize: vertical;
          margin-bottom: 8px;
        }
        .__editor_comment_popup__ button {
          background: #3b82f6;
          color: #fff;
          border: none;
          border-radius: 6px;
          padding: 6px 16px;
          cursor: pointer;
          font-size: 13px;
        }
        .__editor_loader__ {
          position: absolute;
          inset: 0;
          background: rgba(255,255,255,0.85);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 9998;
          font-size: 14px;
          color: #333;
          border-radius: inherit;
        }
        .__editor_collapsed__ > *:not(.__editor_toolbar__) {
          display: none !important;
        }
      `;
      iDoc.head.appendChild(style);

      let hoverTimeout = null;
      let currentToolbar = null;

      const onMouseOver = (e) => {
        const block = e.target.closest('[data-block-id]');
        if (!block) return;

        clearTimeout(hoverTimeout);
        block.classList.add('__editor_hover__');

        if (currentToolbar && currentToolbar.parentElement !== block) {
          currentToolbar.remove();
          currentToolbar = null;
        }
        if (!currentToolbar) {
          currentToolbar = createBlockToolbar(block, iDoc);
          // Ensure the block has position:relative for absolute toolbar
          if (getComputedStyle(block).position === 'static') {
            block.style.position = 'relative';
          }
          block.appendChild(currentToolbar);
        }
      };

      const onMouseOut = (e) => {
        const block = e.target.closest('[data-block-id]');
        if (!block) return;

        hoverTimeout = setTimeout(() => {
          // Check if mouse is still over this block or its toolbar
          const hovered = iDoc.querySelectorAll(':hover');
          for (const el of hovered) {
            if (el === block || block.contains(el)) return;
          }
          block.classList.remove('__editor_hover__');
          if (currentToolbar && currentToolbar.parentElement === block) {
            currentToolbar.remove();
            currentToolbar = null;
          }
        }, 200);
      };

      iDoc.body.addEventListener('mouseover', onMouseOver);
      iDoc.body.addEventListener('mouseout', onMouseOut);

      // Store references for cleanup
      iDoc.body.__editorMouseOver = onMouseOver;
      iDoc.body.__editorMouseOut = onMouseOut;
    }

    function createBlockToolbar(block, iDoc) {
      const toolbar = iDoc.createElement('div');
      toolbar.className = '__editor_toolbar__';

      const blockType = block.getAttribute('data-block-type');
      const isCollapsed = block.classList.contains('__editor_collapsed__');

      // Delete button
      const delBtn = iDoc.createElement('button');
      delBtn.textContent = '🗑';
      delBtn.title = 'Удалить блок';
      delBtn.onclick = (e) => {
        e.stopPropagation();
        pushSnapshot();
        if (blockType === 'company-card' || blockType === 'company-row') {
          block.remove();
          recalcCompanyRanks(iDoc);
        } else {
          block.remove();
        }
        syncCanvasRawHtml();
        if (editorActive) injectEditorListeners(iDoc);
      };
      toolbar.appendChild(delBtn);

      // Comment button
      const commentBtn = iDoc.createElement('button');
      commentBtn.textContent = '💬';
      commentBtn.title = 'Комментарий к блоку';
      commentBtn.onclick = (e) => {
        e.stopPropagation();
        openCommentPopup(block, iDoc);
      };
      toolbar.appendChild(commentBtn);

      // Collapse/expand button
      const collapseBtn = iDoc.createElement('button');
      collapseBtn.textContent = isCollapsed ? '↕ ▸' : '↕ ▾';
      collapseBtn.title = isCollapsed ? 'Развернуть' : 'Свернуть';
      collapseBtn.onclick = (e) => {
        e.stopPropagation();
        block.classList.toggle('__editor_collapsed__');
        collapseBtn.textContent = block.classList.contains('__editor_collapsed__') ? '↕ ▸' : '↕ ▾';
        collapseBtn.title = block.classList.contains('__editor_collapsed__') ? 'Развернуть' : 'Свернуть';
      };
      toolbar.appendChild(collapseBtn);

      return toolbar;
    }

    // =============================================
    // 3B.3 — Delete company with rank recalc
    // =============================================
    function recalcCompanyRanks(iDoc) {
      const allRanked = Array.from(iDoc.querySelectorAll('[data-company-rank]'));
      // Sort by DOM order (already in order from querySelectorAll)
      allRanked.forEach((el, idx) => {
        const oldRank = el.getAttribute('data-company-rank');
        const newRank = String(idx + 1);
        el.setAttribute('data-company-rank', newRank);

        // Update visual rank number inside the element
        // Look for first element that contains just the old rank number
        const walker = iDoc.createTreeWalker(el, NodeFilter.SHOW_TEXT);
        while (walker.nextNode()) {
          const node = walker.currentNode;
          const trimmed = node.textContent.trim();
          if (trimmed === oldRank || trimmed === '#' + oldRank || trimmed === oldRank + '.') {
            node.textContent = node.textContent.replace(oldRank, newRank);
            break;
          }
        }
      });

      // Update Schema.org JSON-LD ItemList
      const scripts = iDoc.querySelectorAll('script[type="application/ld+json"]');
      scripts.forEach(script => {
        try {
          const json = JSON.parse(script.textContent);
          if (json['@type'] === 'ItemList' && Array.isArray(json.itemListElement)) {
            // Remove items whose name/position no longer exists
            // Re-index positions
            json.itemListElement.forEach((item, idx) => {
              item.position = idx + 1;
            });
            // If items were deleted, we need to reconcile — but we can only re-index
            // The delete already removed the DOM element; ItemList entries won't auto-sync
            // So we just re-number what's left
            script.textContent = JSON.stringify(json, null, 2);
          }
        } catch (e) { /* ignore parse errors */ }
      });
    }

    // =============================================
    // 3B.4 — Block regeneration via comment
    // =============================================
    function openCommentPopup(block, iDoc) {
      // Remove existing popups
      iDoc.querySelectorAll('.__editor_comment_popup__').forEach(p => p.remove());

      const popup = iDoc.createElement('div');
      popup.className = '__editor_comment_popup__';

      const textarea = iDoc.createElement('textarea');
      textarea.placeholder = 'Опишите, что изменить в этом блоке...';
      popup.appendChild(textarea);

      const sendBtn = iDoc.createElement('button');
      sendBtn.textContent = 'Отправить';
      sendBtn.onclick = async () => {
        const userComment = textarea.value.trim();
        if (!userComment) return;
        popup.remove();
        await regenerateBlock(block, userComment, iDoc);
      };
      popup.appendChild(sendBtn);

      if (getComputedStyle(block).position === 'static') {
        block.style.position = 'relative';
      }
      block.appendChild(popup);
      textarea.focus();
    }

    async function regenerateBlock(block, userComment, iDoc) {
      const apiKey = localStorage.getItem("openrouter_key") || document.getElementById("apiKey")?.value?.trim() || '';
      if (!apiKey) return showNotification('Нет API-ключа OpenRouter', true);

      // Save snapshot for undo
      pushSnapshot();

      // Show loader on block
      const loader = iDoc.createElement('div');
      loader.className = '__editor_loader__';
      loader.innerHTML = '<div style="text-align:center;"><div style="border:3px solid #e5e7eb;border-top-color:#3b82f6;border-radius:50%;width:28px;height:28px;animation:spin 0.8s linear infinite;margin:0 auto 8px;"></div>Регенерация...</div>';
      // Add spin keyframes if not present
      if (!iDoc.getElementById('__editor_spin_style__')) {
        const spinStyle = iDoc.createElement('style');
        spinStyle.id = '__editor_spin_style__';
        spinStyle.textContent = '@keyframes spin { to { transform: rotate(360deg); } }';
        iDoc.head.appendChild(spinStyle);
      }
      if (getComputedStyle(block).position === 'static') {
        block.style.position = 'relative';
      }
      block.appendChild(loader);

      // Collect context — minimal CSS for speed
      const blockHtml = block.outerHTML;
      const siteLang = document.getElementById('siteLang')?.value || 'Русский';

      // Extract only :root vars and classes used in the block
      const allStyles = Array.from(iDoc.querySelectorAll('style')).map(s => s.textContent).join('\n');
      const rootMatch = allStyles.match(/:root\s*\{[^}]*\}/g);
      const rootVars = rootMatch ? rootMatch.join('\n') : '';
      // Find class names used in block HTML
      const classNames = new Set();
      (blockHtml.match(/class="([^"]*)"/g) || []).forEach(m => {
        m.replace(/class="([^"]*)"/, '$1').split(/\s+/).forEach(c => { if (c && !c.startsWith('__editor')) classNames.add(c); });
      });
      // Extract only matching CSS rules (up to 4000 chars)
      let relevantCSS = rootVars + '\n';
      if (classNames.size > 0) {
        const classPattern = new RegExp('\\.' + [...classNames].map(c => c.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|\\.'), 'g');
        const rules = allStyles.match(/[^{}]*\{[^}]*\}/g) || [];
        for (const rule of rules) {
          if (classPattern.test(rule)) {
            relevantCSS += rule + '\n';
            if (relevantCSS.length > 4000) break;
          }
        }
      }

      const regenPrompt = `РОЛЬ: Ты — фронтенд-разработчик. Перерисуй HTML-блок по инструкции пользователя.

ЯЗЫК КОНТЕНТА: ${siteLang}

СТИЛЕВОЙ КОНТЕКСТ (CSS-переменные и классы блока):
<site_styles>
${relevantCSS}
</site_styles>

ТЕКУЩИЙ HTML БЛОКА:
<current_block>
${blockHtml}
</current_block>

ИНСТРУКЦИЯ ПОЛЬЗОВАТЕЛЯ:
${userComment}

ПРАВИЛА:
1. Верни ТОЛЬКО обновлённый HTML блока — один корневой элемент <section data-block-id="..." data-block-type="...">
2. Сохрани ВСЕ data-атрибуты (data-block-id, data-block-type, data-company-rank) без изменений
3. Используй ТОЛЬКО те CSS-классы, custom properties (:root переменные) и шрифты, которые определены в стилевом контексте
4. Если пользователь просит изменить визуал но сохранить текст — сохрани весь текстовый контент дословно
5. Не добавляй новые <style>, <link> или <script> теги
6. Не используй inline-стили, которые конфликтуют с существующими CSS custom properties
7. Формат ответа: только HTML, без пояснений, без markdown, без обёрток в тройные бэктики`;

      try {
        const data = await callModel("anthropic/claude-haiku-4.5", [{ role: "user", content: regenPrompt }], apiKey);

        if (data.error) {
          loader.remove();
          showNotification('Ошибка регенерации: ' + data.error, true);
          editorUndo();
          return;
        }

        let newHtml = data.content;
        newHtml = newHtml.replace(/^```html?\s*\n?/i, '').replace(/\n?```\s*$/i, '').trim();

        block.outerHTML = newHtml;
        loader.remove();
        syncCanvasRawHtml();
        if (editorActive) injectEditorListeners(iDoc);
      } catch (err) {
        loader.remove();
        showNotification('Ошибка регенерации: ' + err.message, true);
        editorUndo();
      }
    }

    function removeEditorOverlays(iDoc) {
      if (!iDoc) return;
      // Remove injected style
      const style = iDoc.getElementById('__editor_style__');
      if (style) style.remove();
      // Remove all toolbars and popups
      iDoc.querySelectorAll('.__editor_toolbar__, .__editor_comment_popup__, .__editor_loader__').forEach(el => el.remove());
      // Remove hover classes
      iDoc.querySelectorAll('.__editor_hover__').forEach(el => el.classList.remove('__editor_hover__'));
      // Remove event listeners
      if (iDoc.body?.__editorMouseOver) {
        iDoc.body.removeEventListener('mouseover', iDoc.body.__editorMouseOver);
        iDoc.body.removeEventListener('mouseout', iDoc.body.__editorMouseOut);
        delete iDoc.body.__editorMouseOver;
        delete iDoc.body.__editorMouseOut;
      }
    }

    // =============================================
    // 3B.7 — Download HTML
    // =============================================
    function downloadHtml() {
      const iframe = document.getElementById('canvas-iframe');
      const iDoc = iframe.contentDocument;
      if (!iDoc) return showNotification('Нет сгенерированного сайта', true);

      // Clone the document to clean up editor artifacts
      let html = '<!DOCTYPE html>' + iDoc.documentElement.outerHTML;

      // Remove editor artifacts
      html = html.replace(/<style id="__editor_style__">[\s\S]*?<\/style>/g, '');
      html = html.replace(/<style id="__editor_spin_style__">[\s\S]*?<\/style>/g, '');
      html = html.replace(/<div class="__editor_toolbar__">[\s\S]*?<\/div>/g, '');
      html = html.replace(/<div class="__editor_comment_popup__">[\s\S]*?<\/div>/g, '');
      html = html.replace(/<div class="__editor_loader__">[\s\S]*?<\/div>/g, '');
      html = html.replace(/ ?class="__editor_hover__"/g, '');
      html = html.replace(/ ?class="__editor_collapsed__"/g, '');
      // Clean outline inline styles added by editor
      html = html.replace(/ style="position: relative;"/g, '');

      const dlProject = currentProjectId ? getProjects().find(p => p.id === currentProjectId) : null;
      const dlNiche = dlProject?.niche || 'site';
      const dateStr = new Date().toISOString().slice(0, 10);
      const filename = `rating-${dlNiche.replace(/[^a-zA-Zа-яА-Я0-9]/g, '_')}-${dateStr}.html`;

      const blob = new Blob([html], { type: 'text/html; charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
    }

    // =============================================
    // Keyboard shortcuts for undo/redo (main window iframe)
    // =============================================
    document.addEventListener('keydown', (e) => {
      if (!editorActive) return;
      if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
        e.preventDefault();
        editorUndo();
      }
      if ((e.ctrlKey || e.metaKey) && e.key === 'z' && e.shiftKey) {
        e.preventDefault();
        editorRedo();
      }
    });

    // =============================================
    // Правка #8 — Editor in separate window (window.open)
    // =============================================
    let editorWindow = null;
    let editorWindowDirty = false;

    function openInEditor() {
      if (!canvasRawHtml) return showNotification('Сначала сгенерируйте сайт', true);

      editorWindow = window.open('', '_blank');
      if (!editorWindow) return showNotification('Браузер заблокировал popup — разрешите всплывающие окна', true);

      editorWindow.document.open();
      editorWindow.document.write(canvasRawHtml);
      editorWindow.document.close();

      // Wait for document to load, then inject editor
      editorWindow.addEventListener('load', () => {
        injectEditor(editorWindow);
      });
      // Fallback if load already fired
      setTimeout(() => {
        if (editorWindow && editorWindow.document.body && !editorWindow.document.getElementById('__ew_toolbar__')) {
          injectEditor(editorWindow);
        }
      }, 500);
    }

    function injectEditor(win) {
      const doc = win.document;

      // Pass config to editor window
      const edProject = currentProjectId ? getProjects().find(p => p.id === currentProjectId) : null;
      win.__EDITOR_CONFIG__ = {
        apiKey: localStorage.getItem("openrouter_key") || '',
        model: 'anthropic/claude-haiku-4.5',
        siteLang: edProject?.site_lang || 'Русский',
        projectId: currentProjectId
      };

      // Add padding-top for toolbar
      doc.body.style.paddingTop = '50px';

      // Inject toolbar
      const toolbar = doc.createElement('div');
      toolbar.id = '__ew_toolbar__';
      toolbar.innerHTML = `
        <label style="display:flex;align-items:center;gap:6px;cursor:pointer;">
          <input type="checkbox" id="__ew_edit_toggle__"> Редактирование
        </label>
        <button id="__ew_undo__" disabled style="opacity:0.4;">↩ Отменить</button>
        <button id="__ew_redo__" disabled style="opacity:0.4;">↪ Повторить</button>
        <span style="flex:1;"></span>
        <button id="__ew_seo__">SEO</button>
        <button id="__ew_save__" style="background:#238636;border-color:#238636;color:#fff;">Сохранить</button>
        <button id="__ew_download__" style="background:#1f6feb;border-color:#1f6feb;color:#fff;">Скачать HTML</button>
      `;
      Object.assign(toolbar.style, {
        position: 'fixed', top: '0', left: '0', right: '0', zIndex: '99999',
        height: '44px', display: 'flex', alignItems: 'center', gap: '8px',
        padding: '0 16px', background: '#1c2128', borderBottom: '1px solid #30363d',
        fontFamily: '-apple-system,BlinkMacSystemFont,sans-serif', fontSize: '13px', color: '#e1e4e8'
      });
      // Style buttons
      const btnStyle = 'background:#21262d;border:1px solid #30363d;border-radius:6px;padding:5px 10px;color:#c9d1d9;cursor:pointer;font-size:12px;';
      toolbar.querySelectorAll('button').forEach(b => b.style.cssText += btnStyle);

      doc.body.insertBefore(toolbar, doc.body.firstChild);

      // Editor state for this window
      let ewEditorActive = false;
      let ewHistoryStack = [];
      let ewHistoryIndex = -1;

      function ewPushSnapshot() {
        const snap = doc.body.innerHTML;
        ewHistoryStack = ewHistoryStack.slice(0, ewHistoryIndex + 1);
        ewHistoryStack.push(snap);
        if (ewHistoryStack.length > 20) ewHistoryStack.shift();
        ewHistoryIndex = ewHistoryStack.length - 1;
        ewUpdateUndoRedo();
        editorWindowDirty = true;
      }

      function ewUndo() {
        if (ewHistoryIndex <= 0) return;
        ewHistoryIndex--;
        doc.body.innerHTML = ewHistoryStack[ewHistoryIndex];
        doc.body.style.paddingTop = '50px';
        if (ewEditorActive) ewInjectListeners();
        ewUpdateUndoRedo();
        ewSyncBack();
      }

      function ewRedo() {
        if (ewHistoryIndex >= ewHistoryStack.length - 1) return;
        ewHistoryIndex++;
        doc.body.innerHTML = ewHistoryStack[ewHistoryIndex];
        doc.body.style.paddingTop = '50px';
        if (ewEditorActive) ewInjectListeners();
        ewUpdateUndoRedo();
        ewSyncBack();
      }

      function ewUpdateUndoRedo() {
        const undo = doc.getElementById('__ew_undo__');
        const redo = doc.getElementById('__ew_redo__');
        if (undo) { undo.disabled = ewHistoryIndex <= 0; undo.style.opacity = ewHistoryIndex <= 0 ? '0.4' : '1'; }
        if (redo) { redo.disabled = ewHistoryIndex >= ewHistoryStack.length - 1; redo.style.opacity = ewHistoryIndex >= ewHistoryStack.length - 1 ? '0.4' : '1'; }
      }

      function ewSyncBack() {
        // Sync HTML back to main window
        const clean = ewGetCleanHtml();
        canvasRawHtml = clean;
        if (window.opener && !window.opener.closed) {
          window.opener.canvasRawHtml = clean;
        }
        editorWindowDirty = true;
      }

      function ewGetCleanHtml() {
        let html = '<!DOCTYPE html>' + doc.documentElement.outerHTML;
        // Remove editor toolbar
        html = html.replace(/<div id="__ew_toolbar__">[\s\S]*?<\/div>\s*/, '');
        // Remove editor styles and artifacts
        html = html.replace(/<style id="__editor_style__">[\s\S]*?<\/style>/g, '');
        html = html.replace(/<style id="__editor_spin_style__">[\s\S]*?<\/style>/g, '');
        html = html.replace(/<div class="__editor_toolbar__">[\s\S]*?<\/div>/g, '');
        html = html.replace(/<div class="__editor_comment_popup__">[\s\S]*?<\/div>/g, '');
        html = html.replace(/<div class="__editor_loader__">[\s\S]*?<\/div>/g, '');
        html = html.replace(/ ?class="__editor_hover__"/g, '');
        html = html.replace(/ ?class="__editor_collapsed__"/g, '');
        html = html.replace(/ style="position: relative;"/g, '');
        html = html.replace(/ style="padding-top: 50px;"/g, '');
        // Remove SEO panel if injected
        html = html.replace(/<div id="__ew_seo_panel__">[\s\S]*?<\/div>\s*<\/div>/g, '');
        return html;
      }

      // Toggle edit mode
      doc.getElementById('__ew_edit_toggle__').onchange = function() {
        ewEditorActive = this.checked;
        if (ewEditorActive) {
          if (ewHistoryStack.length === 0) ewPushSnapshot();
          ewInjectListeners();
        } else {
          removeEditorOverlays(doc);
        }
      };

      // Undo / Redo
      doc.getElementById('__ew_undo__').onclick = ewUndo;
      doc.getElementById('__ew_redo__').onclick = ewRedo;

      // Keyboard shortcuts
      doc.addEventListener('keydown', (e) => {
        if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
          e.preventDefault();
          ewUndo();
        }
        if ((e.ctrlKey || e.metaKey) && e.key === 'z' && e.shiftKey) {
          e.preventDefault();
          ewRedo();
        }
        // Ctrl+S = save
        if ((e.ctrlKey || e.metaKey) && e.key === 's') {
          e.preventDefault();
          ewSave();
        }
      });

      // Save to localStorage via opener
      function ewSave() {
        const clean = ewGetCleanHtml();
        canvasRawHtml = clean;
        if (window.opener && !window.opener.closed) {
          window.opener.canvasRawHtml = clean;
          if (window.opener.updateProjectHtml) window.opener.updateProjectHtml(clean);
          if (window.opener.updateProjectStatus) window.opener.updateProjectStatus('edited', clean);
        }

        editorWindowDirty = false;
        ewShowNotification('Сохранено');
      }

      doc.getElementById('__ew_save__').onclick = ewSave;

      // Download HTML
      doc.getElementById('__ew_download__').onclick = function() {
        const clean = ewGetCleanHtml();
        const openerProject = window.opener?.currentProjectId ? window.opener.getProjects().find(p => p.id === window.opener.currentProjectId) : null;
        const niche = openerProject?.niche || 'site';
        const dateStr = new Date().toISOString().slice(0, 10);
        const filename = `rating-${niche.replace(/[^a-zA-Zа-яА-Я0-9]/g, '_')}-${dateStr}.html`;

        const blob = new Blob([clean], { type: 'text/html; charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = doc.createElement('a');
        a.href = url;
        a.download = filename;
        a.click();
        URL.revokeObjectURL(url);
      };

      // SEO panel toggle
      doc.getElementById('__ew_seo__').onclick = function() {
        let panel = doc.getElementById('__ew_seo_panel__');
        if (panel) {
          panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
          return;
        }
        ewCreateSeoPanel();
      };

      function ewCreateSeoPanel() {
        const panel = doc.createElement('div');
        panel.id = '__ew_seo_panel__';
        Object.assign(panel.style, {
          position: 'fixed', top: '44px', right: '0', width: '360px', maxHeight: 'calc(100vh - 44px)',
          overflowY: 'auto', background: '#161b22', border: '1px solid #30363d', borderTop: 'none',
          zIndex: '99998', padding: '16px', fontFamily: '-apple-system,sans-serif', fontSize: '13px', color: '#e1e4e8'
        });
        const fields = [
          { id: 'counterYandex', label: 'Яндекс.Метрика', type: 'textarea' },
          { id: 'counterGoogle', label: 'Google Analytics / GTM', type: 'textarea' },
          { id: 'metaYandex', label: 'Яндекс.Вебмастер', type: 'input' },
          { id: 'metaGoogle', label: 'Google Search Console', type: 'input' },
          { id: 'metaTitle', label: 'Title', type: 'input' },
          { id: 'metaDesc', label: 'Description', type: 'textarea' },
          { id: 'metaKeywords', label: 'Keywords', type: 'input' },
          { id: 'metaOgImage', label: 'OG Image URL', type: 'input' }
        ];

        // Try to read current values from head
        const currentValues = ewReadSeoFromHead();

        panel.innerHTML = '<h3 style="margin:0 0 12px;font-size:14px;color:#fff;">SEO и счётчики</h3>' +
          fields.map(f => `
            <div style="margin-bottom:10px;">
              <label style="display:block;font-size:12px;color:#8b949e;margin-bottom:4px;">${f.label}</label>
              ${f.type === 'textarea'
                ? `<textarea id="__ew_${f.id}__" style="width:100%;min-height:60px;background:#0d1117;border:1px solid #30363d;border-radius:6px;padding:8px;color:#e1e4e8;font-size:12px;resize:vertical;">${currentValues[f.id] || ''}</textarea>`
                : `<input id="__ew_${f.id}__" value="${currentValues[f.id] || ''}" style="width:100%;background:#0d1117;border:1px solid #30363d;border-radius:6px;padding:8px;color:#e1e4e8;font-size:12px;">`}
            </div>
          `).join('') +
          '<button id="__ew_apply_seo__" style="width:100%;padding:8px;background:#238636;border:1px solid #238636;border-radius:6px;color:#fff;cursor:pointer;font-size:13px;">Применить</button>';

        doc.body.appendChild(panel);

        doc.getElementById('__ew_apply_seo__').onclick = function() {
          ewApplySeo();
        };
      }

      function ewReadSeoFromHead() {
        const vals = {};
        // Read meta title
        const title = doc.querySelector('title');
        if (title) vals.metaTitle = title.textContent;
        // Read meta description
        const desc = doc.querySelector('meta[name="description"]');
        if (desc) vals.metaDesc = desc.getAttribute('content') || '';
        // Read meta keywords
        const kw = doc.querySelector('meta[name="keywords"]');
        if (kw) vals.metaKeywords = kw.getAttribute('content') || '';
        // Read og:image
        const og = doc.querySelector('meta[property="og:image"]');
        if (og) vals.metaOgImage = og.getAttribute('content') || '';
        return vals;
      }

      function ewApplySeo() {
        ewPushSnapshot();
        const head = doc.head;

        // Apply counters inside PROTECTED:COUNTERS block
        const counterYandex = doc.getElementById('__ew_counterYandex__')?.value || '';
        const counterGoogle = doc.getElementById('__ew_counterGoogle__')?.value || '';
        let countersContent = '';
        if (counterYandex) countersContent += counterYandex + '\n';
        if (counterGoogle) countersContent += counterGoogle + '\n';

        const headHtml = head.innerHTML;
        if (headHtml.includes('<!-- PROTECTED:COUNTERS:START -->')) {
          head.innerHTML = headHtml.replace(
            /<!-- PROTECTED:COUNTERS:START -->[\s\S]*?<!-- PROTECTED:COUNTERS:END -->/,
            `<!-- PROTECTED:COUNTERS:START -->\n${countersContent}<!-- PROTECTED:COUNTERS:END -->`
          );
        }

        // Apply SEO meta inside PROTECTED:SEO block
        const metaYandex = doc.getElementById('__ew_metaYandex__')?.value || '';
        const metaGoogle = doc.getElementById('__ew_metaGoogle__')?.value || '';
        const metaTitle = doc.getElementById('__ew_metaTitle__')?.value || '';
        const metaDesc = doc.getElementById('__ew_metaDesc__')?.value || '';
        const metaKeywords = doc.getElementById('__ew_metaKeywords__')?.value || '';
        const metaOgImage = doc.getElementById('__ew_metaOgImage__')?.value || '';

        let seoContent = '';
        if (metaYandex) seoContent += `<meta name="yandex-verification" content="${metaYandex}">\n`;
        if (metaGoogle) seoContent += `<meta name="google-site-verification" content="${metaGoogle}">\n`;
        if (metaTitle) {
          const titleEl = doc.querySelector('title');
          if (titleEl) titleEl.textContent = metaTitle;
        }
        if (metaDesc) seoContent += `<meta name="description" content="${metaDesc}">\n`;
        if (metaKeywords) seoContent += `<meta name="keywords" content="${metaKeywords}">\n`;
        if (metaOgImage) seoContent += `<meta property="og:image" content="${metaOgImage}">\n`;

        const headHtml2 = head.innerHTML;
        if (headHtml2.includes('<!-- PROTECTED:SEO:START -->')) {
          head.innerHTML = headHtml2.replace(
            /<!-- PROTECTED:SEO:START -->[\s\S]*?<!-- PROTECTED:SEO:END -->/,
            `<!-- PROTECTED:SEO:START -->\n${seoContent}<!-- PROTECTED:SEO:END -->`
          );
        }

        ewSyncBack();
        ewShowNotification('SEO применено');
      }

      function ewShowNotification(msg) {
        let note = doc.getElementById('__ew_notification__');
        if (note) note.remove();
        note = doc.createElement('div');
        note.id = '__ew_notification__';
        Object.assign(note.style, {
          position: 'fixed', bottom: '20px', right: '20px', zIndex: '100000',
          background: '#238636', color: '#fff', padding: '10px 20px', borderRadius: '8px',
          fontSize: '13px', animation: 'fadeInOut 2.5s ease forwards'
        });
        // Add animation keyframes if needed
        if (!doc.getElementById('__ew_anim_style__')) {
          const animStyle = doc.createElement('style');
          animStyle.id = '__ew_anim_style__';
          animStyle.textContent = '@keyframes fadeInOut { 0%{opacity:0;transform:translateY(10px)} 15%{opacity:1;transform:translateY(0)} 80%{opacity:1} 100%{opacity:0} }';
          doc.head.appendChild(animStyle);
        }
        note.textContent = msg;
        doc.body.appendChild(note);
        setTimeout(() => note.remove(), 2500);
      }

      // Hover overlay + toolbar injection (same as 3B.2 but for editor window)
      function ewInjectListeners() {
        removeEditorOverlays(doc);
        injectEditorListeners(doc);

        // Override the callModel for regeneration to use editor window's apiKey
        // The existing injectEditorListeners/createBlockToolbar use the main window's functions
        // which reference iframe.contentDocument — but we're now using doc directly.
        // The functions (injectEditorListeners, createBlockToolbar, etc.) already accept iDoc parameter
        // so they work with any document. The regenerateBlock function uses document.getElementById("apiKey")
        // which will correctly reference the main window.
      }

      // Before unload warning
      win.addEventListener('beforeunload', (e) => {
        if (editorWindowDirty) {
          e.preventDefault();
          e.returnValue = 'Есть несохранённые изменения. Закрыть?';
        }
      });
    }

    function updatePreview() {
      const niche = document.getElementById("niche").value.trim();
      const geo = document.getElementById("geo").value.trim();
      const geoStr = geo ? ` в <span class="highlight">${geo}</span>` : '';
      document.getElementById("preview").innerHTML =
        `Составь список 30 <span class="highlight">${niche || "..."}</span>${geoStr}`;
    }

    function toggleApiKey() {
      const input = document.getElementById("apiKey");
      const btn = document.getElementById("toggleBtn");
      if (input.type === "password") {
        input.type = "text";
        btn.textContent = "скрыть";
      } else {
        input.type = "password";
        btn.textContent = "показать";
      }
    }

    function getBadgeClass(modelId) {
      if (modelId.includes("openai")) return "badge-chatgpt";
      if (modelId.includes("google")) return "badge-gemini";
      if (modelId.includes("anthropic")) return "badge-claude";
      return "";
    }

    function getBadgeLabel(modelId) {
      if (modelId.includes("openai")) return "ChatGPT";
      if (modelId.includes("google")) return "Gemini";
      if (modelId.includes("anthropic")) return "Claude";
      return "AI";
    }

    function renderCard(modelId) {
      const model = MODELS.find(m => m.id === modelId);
      const card = document.getElementById(`card-${CSS.escape(modelId)}`);
      if (!card || !model) return;

      const msgs = conversations[modelId] || [];
      const badgeClass = getBadgeClass(modelId);
      const badgeLabel = getBadgeLabel(modelId);

      let messagesHtml = "";
      for (const msg of msgs) {
        const isUser = msg.role === "user";
        messagesHtml += `
          <div class="chat-msg ${isUser ? "chat-msg-user" : "chat-msg-assistant"}">
            <div class="chat-msg-label">${isUser ? "Вы" : badgeLabel}</div>
            <div>${msg.content}</div>
          </div>`;
      }

      card.innerHTML = `
        <div class="result-header">
          <span class="model-badge ${badgeClass}">${badgeLabel}</span>
          <span class="model-name">${model.name}</span>
        </div>
        <div class="chat-messages" id="msgs-${CSS.escape(modelId)}">${messagesHtml}</div>
        <div class="chat-input-area">
          <input type="text" id="input-${CSS.escape(modelId)}" placeholder="Задать вопрос..." onkeydown="if(event.key==='Enter')sendFollowUp('${modelId}')" />
          <button onclick="sendFollowUp('${modelId}')">Отправить</button>
        </div>`;

      // Scroll chat to bottom
      const msgsEl = document.getElementById(`msgs-${CSS.escape(modelId)}`);
      if (msgsEl) msgsEl.scrollTop = msgsEl.scrollHeight;
    }

    async function sendFollowUp(modelId) {
      const apiKey = localStorage.getItem("openrouter_key") || '';
      const inputEl = document.getElementById(`input-${CSS.escape(modelId)}`);
      const question = inputEl.value.trim();
      if (!question || !apiKey) return;

      // Add user message with language context
      const project = currentProjectId ? getProjects().find(p => p.id === currentProjectId) : null;
      const followUpLang = project?.query_lang || 'Русский';
      const followUpLangStr = `Отвечай на языке: ${followUpLang}`;
      conversations[modelId].push({ role: "user", content: `ЯЗЫК ОТВЕТА: ${followUpLangStr}\n\n${question}` });
      inputEl.value = "";
      renderCard(modelId);

      // Show loading
      const msgsEl = document.getElementById(`msgs-${CSS.escape(modelId)}`);
      const loadingDiv = document.createElement("div");
      loadingDiv.className = "chat-msg chat-msg-assistant";
      loadingDiv.innerHTML = `<div class="chat-msg-label">${getBadgeLabel(modelId)}</div><div><span class="spinner-small"></span> Думает...</div>`;
      msgsEl.appendChild(loadingDiv);
      msgsEl.scrollTop = msgsEl.scrollHeight;

      // Disable input
      const btnEl = inputEl.nextElementSibling;
      inputEl.disabled = true;
      btnEl.disabled = true;

      try {
        const data = await callModel(modelId, conversations[modelId], apiKey);

        if (data.error) {
          conversations[modelId].push({ role: "assistant", content: `[Ошибка] ${data.error}` });
        } else {
          conversations[modelId].push({ role: "assistant", content: data.content });
        }
      } catch (err) {
        conversations[modelId].push({ role: "assistant", content: `[Ошибка] ${err.message}` });
      }

      inputEl.disabled = false;
      btnEl.disabled = false;
      renderCard(modelId);
    }

    // === Pipeline Execution ===
    let pipelineRunning = false;

    async function runPipeline(projectId, startFrom = null) {
      if (pipelineRunning) return showNotification('Пайплайн уже запущен', true);
      pipelineRunning = true;

      const project = getProjects().find(p => p.id === projectId);
      if (!project) { pipelineRunning = false; return; }

      currentProjectId = projectId;
      const apiKey = localStorage.getItem("openrouter_key");
      if (!apiKey) { pipelineRunning = false; return alert("Нет API-ключа OpenRouter. Создайте новый проект."); }

      // Extract params from project
      const { niche, geo, geo_request, query_lang, site_lang } = project;
      const geoStr = geo ? ` в ${geo}` : '';
      const geoRequestStr = geo_request ? `Отвечай с перспективы пользователя, который находится в ${geo_request}` : '';
      const queryLangStr = `Отвечай на языке: ${query_lang || 'Русский'}`;
      const siteLangStr = `Весь контент сайта на языке: ${site_lang || 'Русский'}`;
      const contextBlock = (geoRequestStr ? `\nКОНТЕКСТ ЛОКАЦИИ: ${geoRequestStr}` : '') + `\nЯЗЫК ОТВЕТА: ${queryLangStr}`;

      // Hide resume bar
      const resumeBar = document.getElementById('project-resume-bar');
      if (resumeBar) resumeBar.innerHTML = '';

      // Determine which steps to run
      const stepOrder = PIPELINE_STEPS.map(s => s.id);
      let startIdx = 0;
      let grokCriteriaRaw = "";
      let grokAudienceRaw = "";

      if (startFrom) {
        startIdx = stepOrder.indexOf(startFrom);
        if (startIdx < 0) startIdx = 0;
        // Restore state from project meta for resume
        if (project.meta) {
          if (project.meta.conversations) Object.assign(conversations, project.meta.conversations);
          if (project.meta.compilerRawXml) compilerRawXml = project.meta.compilerRawXml;
          if (project.meta.grokCriteriaRaw) grokCriteriaRaw = project.meta.grokCriteriaRaw;
          if (project.meta.grokAudienceRaw) grokAudienceRaw = project.meta.grokAudienceRaw;
          if (project.meta.extractedRatings) extractedRatings = project.meta.extractedRatings;
          if (project.meta.downloadedRatings) downloadedRatings = project.meta.downloadedRatings;
          // designSystemRaw is restored in the step_design block's else-branch
        }
      }

      const resultsDiv = document.getElementById("results");

      try {

      // === STEP 1-2: Three models parallel (companies + criteria) ===
      if (startIdx <= 0) {
        updateTimelineStep('step_1_2', 'running');

        const prompt1 = `Составь список 30 ${niche}${geoStr}${contextBlock}`;
        const prompt2 = `Почему именно эти сервисы были поставлены в ТОП. 1. Составь список критериев, по которым ты оценивал сайты 2. Разгруппируй эти критерии на смысловые группы 3. Отранжируй эти критерии в порядке уменьшения веса влияния на место в рейтинге${contextBlock}`;

        for (const model of MODELS) {
          conversations[model.id] = [{ role: "user", content: prompt1 }];
        }

        resultsDiv.innerHTML = MODELS.map(m => {
          const badgeClass = getBadgeClass(m.id);
          const badgeLabel = getBadgeLabel(m.id);
          return `
            <div class="result-card" id="card-${CSS.escape(m.id)}">
              <div class="result-header">
                <span class="model-badge ${badgeClass}">${badgeLabel}</span>
                <span class="model-name">${m.name}</span>
              </div>
              <div class="loading"><div class="spinner"></div>${badgeLabel} думает... (запрос 1/2)</div>
            </div>`;
        }).join("");

        const promises = MODELS.map(async (model) => {
          try {
            const data1 = await callModel(model.id, conversations[model.id], apiKey);
            if (data1.error) {
              conversations[model.id].push({ role: "assistant", content: `[Ошибка] ${data1.error}` });
              renderCard(model.id);
              return;
            }
            conversations[model.id].push({ role: "assistant", content: data1.content });
          } catch (err) {
            conversations[model.id].push({ role: "assistant", content: `[Ошибка] ${err.message}` });
            renderCard(model.id);
            return;
          }

          renderCard(model.id);
          const msgsEl = document.getElementById(`msgs-${CSS.escape(model.id)}`);
          if (msgsEl) {
            const loadingDiv = document.createElement("div");
            loadingDiv.className = "chat-msg chat-msg-user";
            loadingDiv.innerHTML = `<div class="chat-msg-label">Вы (авто)</div><div style="color:#8b949e"><span class="spinner-small"></span> Отправляю запрос 2/2...</div>`;
            msgsEl.appendChild(loadingDiv);
            msgsEl.scrollTop = msgsEl.scrollHeight;
          }

          conversations[model.id].push({ role: "user", content: prompt2 });

          try {
            const data2 = await callModel(model.id, conversations[model.id], apiKey);
            if (data2.error) {
              conversations[model.id].push({ role: "assistant", content: `[Ошибка] ${data2.error}` });
            } else {
              conversations[model.id].push({ role: "assistant", content: data2.content });
            }
          } catch (err) {
            conversations[model.id].push({ role: "assistant", content: `[Ошибка] ${err.message}` });
          }

          renderCard(model.id);
        });

        await Promise.all(promises);
        updateTimelineStep('step_1_2', 'done');
        updateProjectMeta({ currentStep: 'step_1_2', conversations, resultsHtml: resultsDiv.innerHTML });
      }

      // === STEP 3: Grok criteria deduplication ===
      if (startIdx <= 1) {
        updateTimelineStep('step_3', 'running');

        const criteriaBlocks = MODELS.map(m => {
          const msgs = conversations[m.id] || [];
          const lastAssistant = [...msgs].reverse().find(msg => msg.role === "assistant");
          return `=== ${m.name} ===\n${lastAssistant?.content || "(нет ответа)"}`;
        }).join("\n\n");

        const grokPrompt = `ЯЗЫК ОТВЕТА: ${queryLangStr}

Представь, что ты человек, который провел ресерч данной ниши и тебе необходимо составить собственный рейтинг, который будет оценивать каждую компанию по определенным критериям.

Тебе необходимо выполнить смысловую дедупликацию критериев
Составить итоговую таблицу с критериями (В первом столбце критерий, а во втором столбце методология его оценки)
При разборе запрещается пропускать критерии

ВАЖНО: В ответе выведи ТОЛЬКО итоговую таблицу. Без вступления, без пояснений, без заключения. Только таблица.

Список критериев ниже:
<data>
${criteriaBlocks}
</data>`;

        const grokSection = document.getElementById("grok-section");
        const grokMessages = document.getElementById("grok-messages");
        grokSection.style.display = "block";
        grokMessages.innerHTML = `<div class="loading"><div class="spinner"></div>Grok анализирует критерии...</div>`;
        grokSection.scrollIntoView({ behavior: "smooth" });

        try {
          const grokData = await callModel("x-ai/grok-4", [{ role: "user", content: grokPrompt }], apiKey);
          if (grokData.error) {
            grokMessages.innerHTML = `<div class="chat-msg chat-msg-assistant"><div class="chat-msg-label">Grok</div><div class="error-text">[Ошибка] ${grokData.error}</div></div>`;
          } else {
            grokCriteriaRaw = grokData.content;
            const tableHtml = mdTableToHtml(grokData.content);
            const rendered = tableHtml
              ? `<div class="grok-table-wrap">${tableHtml}</div>`
              : `<div style="white-space:pre-wrap">${grokData.content}</div>`;
            grokMessages.innerHTML = `
              <div class="chat-msg chat-msg-assistant" style="padding:20px;">
                ${rendered}
              </div>`;
          }
        } catch (err) {
          grokMessages.innerHTML = `<div class="chat-msg chat-msg-assistant"><div class="chat-msg-label">Grok</div><div class="error-text">[Ошибка] ${err.message}</div></div>`;
        }

        updateTimelineStep('step_3', 'done');
        updateProjectMeta({ currentStep: 'step_3', grokCriteriaRaw, grokCriteriaHtml: grokMessages.innerHTML });
      }

      // === STEP 4: Grok audience analysis ===
      if (startIdx <= 2) {
        updateTimelineStep('step_4', 'running');

        const audiencePrompt = `ЯЗЫК ОТВЕТА: ${queryLangStr}

Ты — маркетолог-аналитик и UX-специалист. Тебе дана ниша: "${niche}".

Смоделируй 4 сегмента целевой аудитории для компаний в этой нише.

Для каждого сегмента ЦА составь подробный список их болей, вопросов и интентов (не менее 15–20 пунктов).

Ответ выведи в два блока:

БЛОК 1 — markdown-таблица с двумя столбцами. Каждая боль/интент — ОТДЕЛЬНАЯ строка.

| ЦА | Боль / Интент |
|---|---|
| Малый бизнес | Хочу понять стоимость до покупки |
| Малый бизнес | Боюсь сложной интеграции |
| Корпорации | Нужна масштабируемость |

БЛОК 2 — после таблицы, через разделитель "---", выведи краткие портреты каждой ЦА в формате:

---
**Малый бизнес:** Владелец компании до 50 чел., ищет автоматизацию...
**Корпорации:** IT-директор крупной компании...

Без вступления и заключения.`;

        const audienceSection = document.getElementById("audience-section");
        const audienceMessages = document.getElementById("audience-messages");
        audienceSection.style.display = "block";
        audienceMessages.innerHTML = `<div class="loading"><div class="spinner"></div>Grok анализирует аудитории...</div>`;
        audienceSection.scrollIntoView({ behavior: "smooth" });

        try {
          const audData = await callModel("x-ai/grok-4", [{ role: "user", content: audiencePrompt }], apiKey);
          if (audData.error) {
            audienceMessages.innerHTML = `<div class="chat-msg chat-msg-assistant"><div class="chat-msg-label">Grok</div><div class="error-text">[Ошибка] ${audData.error}</div></div>`;
          } else {
            grokAudienceRaw = audData.content;
            const parsed = parseAudienceResponse(audData.content);
            if (parsed) {
              audienceMessages.innerHTML = `
                <div class="chat-msg chat-msg-assistant" style="padding:20px;">
                  <div class="grok-table-wrap">${parsed.tableHtml}</div>
                  ${parsed.portraitsHtml}
                </div>`;
            } else {
              audienceMessages.innerHTML = `
                <div class="chat-msg chat-msg-assistant" style="padding:20px;">
                  <div style="white-space:pre-wrap">${audData.content}</div>
                </div>`;
            }
          }
        } catch (err) {
          audienceMessages.innerHTML = `<div class="chat-msg chat-msg-assistant"><div class="chat-msg-label">Grok</div><div class="error-text">[Ошибка] ${err.message}</div></div>`;
        }

        updateTimelineStep('step_4', 'done');
        updateProjectMeta({ currentStep: 'step_4', grokCriteriaRaw, grokAudienceRaw, audienceHtml: audienceMessages.innerHTML });
      }

      // === STEP DESIGN: Generate design system via BM25 ===
      let designSystemRaw = '';

      if (startIdx <= 3) {
        updateTimelineStep('step_design', 'running');
        const designSection = document.getElementById('design-section');
        if (designSection) designSection.style.display = '';

        try {
          // Translate niche to English if it contains Cyrillic (CSV data is in English)
          let designQuery = niche + ' ' + (geo || '');
          if (/[а-яёА-ЯЁ]/.test(designQuery)) {
            try {
              const translateResp = await callModel(
                'google/gemini-2.0-flash-001',
                [{ role: 'user', content: `Translate this business niche to English in 2-4 keywords. Only output keywords, nothing else: ${niche} ${geo || ''}` }],
                apiKey
              );
              const translated = translateResp.trim();
              if (translated && !/error|sorry|не могу/i.test(translated)) {
                console.log(`[step_design] Translated niche: "${niche} ${geo || ''}" → "${translated}"`);
                designQuery = translated;
              }
            } catch (translateErr) {
              console.warn('[step_design] Niche translation failed, using original:', translateErr.message);
            }
          }

          const ds = await generateDesignSystem(designQuery, niche);
          designSystemRaw = formatDesignSystemForPrompt(ds);

          const designMessages = document.getElementById('design-messages');
          if (designMessages) {
            const translationNote = designQuery !== (niche + ' ' + (geo || ''))
              ? `<div style="margin-bottom:12px; padding:8px 12px; background:#1a1f35; border-radius:6px; font-size:12px; color:#7ee787;">🔤 Перевод для BM25: "${niche} ${geo || ''}" → "${designQuery}"</div>`
              : '';
            designMessages.innerHTML = `
              <div class="chat-msg chat-msg-assistant" style="padding:20px">
                <div class="chat-msg-label">Design System (BM25)</div>
                ${translationNote}
                <div style="white-space:pre-wrap; font-size:12px; color:#8b949e">${designSystemRaw.replace(/</g, '&lt;')}</div>
              </div>`;
          }

          updateTimelineStep('step_design', 'done');
          updateProjectMeta({ currentStep: 'step_design', designSystemRaw });
        } catch (err) {
          console.warn('Design system generation failed, using fallback:', err);
          designSystemRaw = DEFAULT_DESIGN_SYSTEM;

          const designMessages = document.getElementById('design-messages');
          if (designMessages) {
            designMessages.innerHTML = `
              <div class="chat-msg chat-msg-assistant" style="padding:20px">
                <div class="chat-msg-label">Design System (fallback)</div>
                <div style="white-space:pre-wrap; font-size:12px; color:#f0883e">[Ошибка загрузки дизайн-данных: ${err.message}]\nИспользуется дизайн-система по умолчанию.</div>
              </div>`;
          }

          updateTimelineStep('step_design', 'done');
          updateProjectMeta({ currentStep: 'step_design', designSystemRaw });
        }
      } else if (project.meta?.designSystemRaw) {
        designSystemRaw = project.meta.designSystemRaw;
      }

      // === STEP 5: Claude XML compiler ===
      if (startIdx <= 4) {
        updateTimelineStep('step_5', 'running');

        const compilerPrompt = `ЯЗЫК ОТВЕТА: ${queryLangStr}

Сейчас мы будем компилировать следующие данные:

=== ИТОГОВЫЙ АНАЛИЗ КРИТЕРИЕВ ===
${grokCriteriaRaw}

=== АУДИТОРИИ И ИХ БОЛИ / ИНТЕНТЫ ===
${grokAudienceRaw}

Это делается для того, чтобы сделать рейтинг-сайт который будет полезным, чтобы цитироваться в LLM.

Ты — эксперт по структурированию критериев для рейтингов компаний. Твоя задача — взять данные выше и преобразовать их в структурированный XML-формат с группами и критериями.

Шаги обработки:
1. Проанализируй текст и разбей на логические группы. Группы должны быть релевантными и охватывать все ключевые аспекты из текста (минимум 4–5 групп). Для каждой группы используй <group name="group_name" title="Группа на русском">.
2. Для каждой группы создай 5–8 критериев на основе данных. Для каждого критерия используй <criterion name="criterion_name">.
3. Внутри каждого <criterion> добавь теги:
   - <name>Название критерия на русском</name>
   - <description>Краткое описание критерия</description>
   - <methodology>Подробная методология измерения/анализа</methodology>
   - <why_important>Краткое объяснение важности, связанное с болями аудитории</why_important>
   - <recommendation>Рекомендации по реализации или улучшению</recommendation>
   - <target>Целевые показатели/значения</target>
   - <example>Пример с данными (придумай реалистичный)</example>
4. Придумай реалистичные метрики и примеры, основываясь на типичных значениях для отрасли "${niche}".
5. Выводи ТОЛЬКО XML-структуру без лишнего текста. Оберни весь вывод в <criteria_structure> ... </criteria_structure>.`;

        const compSection = document.getElementById("compiler-section");
        const compMessages = document.getElementById("compiler-messages");
        compSection.style.display = "block";
        compMessages.innerHTML = `<div class="loading"><div class="spinner"></div>Claude компилирует XML-структуру...</div>`;
        compSection.scrollIntoView({ behavior: "smooth" });

        try {
          const compData = await callModel("anthropic/claude-sonnet-4.5", [{ role: "user", content: compilerPrompt }], apiKey);
          if (compData.error) {
            compMessages.innerHTML = `<div class="chat-msg chat-msg-assistant"><div class="chat-msg-label">Claude</div><div class="error-text">[Ошибка] ${compData.error}</div></div>`;
          } else {
            compilerRawXml = compData.content.replace(/^```xml\s*\n?/i, '').replace(/\n?```\s*$/i, '').trim();
            compMessages.innerHTML = `
              <div class="chat-msg chat-msg-assistant" style="padding:20px;">
                <button class="copy-btn" onclick="navigator.clipboard.writeText(compilerRawXml).then(()=>{this.textContent='Скопировано!';setTimeout(()=>this.textContent='Копировать XML',1500)})">Копировать XML</button>
                <div class="xml-output">${highlightXml(compData.content)}</div>
              </div>`;
          }
        } catch (err) {
          compMessages.innerHTML = `<div class="chat-msg chat-msg-assistant"><div class="chat-msg-label">Claude</div><div class="error-text">[Ошибка] ${err.message}</div></div>`;
        }

        updateTimelineStep('step_5', 'done');
        updateProjectMeta({ currentStep: 'step_5', compilerRawXml, grokCriteriaRaw, grokAudienceRaw, compilerHtml: compMessages.innerHTML });
      }

      // === STEP 6: Claude HTML site generation ===
      if (startIdx <= 5) {
        updateTimelineStep('step_6', 'running');

        const sitePrompt = `ЯЗЫК САЙТА: ${siteLangStr}

РОЛЬ:

Ты — Senior SEO-специалист, эксперт по GEO (Generative Engine Optimization) и Frontend Designer-Engineer.
Ты создаёшь не шаблоны, а memorable, high-craft интерфейсы с чётким aesthetic point of view.
Твоя задача — создать независимый рейтинговый портал (агрегатор) по теме "${niche}"${geoStr}.

ЦЕЛЬ:

Создать единую, полностью самодостаточную HTML-страницу (один файл, inline CSS и JS), которая:

Идеально ранжируется по запросам, связанным с рейтингом компаний в данной нише.

Оптимизирована для цитирования нейросетями (ChatGPT, Gemini, Perplexity). Страница должна стать источником "Ground Truth" для AI.

${designSystemRaw || DEFAULT_DESIGN_SYSTEM}

———————————————————————————
ВАЖНОЕ УСЛОВИЕ (ИНТЕНТЫ)
———————————————————————————

Приведенная ниже структура — это обязательный минимум. Дополнительно сгенерируй 1-2 смысловых блока, которые закроют скрытые интенты пользователя (например: "Карта пунктов выдачи", "Чек-лист проверки инструмента при приемке").

РАЗМЕТКА БЛОКОВ ДЛЯ РЕДАКТОРА:
Каждый смысловой блок сайта оберни в <section data-block-id="block_N" data-block-type="TYPE">

Типы блоков (data-block-type):
- "hero" — главный баннер
- "methodology" — методология
- "company-card" — карточка компании (каждая отдельно), дополнительно добавь data-company-rank="N"
- "company-table" — компактная таблица остальных компаний
- "analytics" — аналитика/графики
- "longread" — SEO-текст
- "faq" — FAQ
- "author" — блок автора
- "custom" — дополнительные смысловые блоки (интенты)

Каждая строка таблицы компаний также оберни:
<tr data-block-id="company_row_N" data-block-type="company-row" data-company-rank="N">

Нумерация data-block-id сквозная, начиная с block_1.
НЕ оборачивай в блоки: <head>, мета-теги, <style>, <script>.

ГЛОБАЛЬНАЯ СТРУКТУРА СТРАНИЦЫ (Секции сверху вниз):

1. SEO Header & Hero Block

Логотип (стилизованный через CSS, не картинка).

H1: Рейтинг компаний в нише "${niche}"${geoStr} — актуальный обзор.

E-E-A-T Элементы:

Виджет "Обновлено: Февраль 2026".

Ссылка на Автора (реалистичное имя эксперта, фото-заглушка).

Дисклеймер о методологии (кратко).

Hero должен иметь сильную entrance-анимацию и визуальный якорь.

2. Блок "Методология и Доверие" (BLUF - Bottom Line Up Front)

Критически важно для AI: Сразу после заголовка дай "Наземную правду".

Краткий текст: "Как мы считали: проанализировано N компаний по M метрикам" — на основе XML.

Сводная таблица лидеров (Quick Summary):

1 место: [Лучший выбор].

2 место: [Лучшая цена].

3 место: [Лучший сервис].

Ссылка "Перейти к полному обзору".

3. ОСНОВНОЙ РЕЙТИНГ (The Core) — ВНИМАНИЕ К ДЕТАЛЯМ!

Включи ВСЕ компании из XML (обычно 20-30). Каждая компания должна быть в рейтинге.
Весь список должен быть обернут в Schema.org/ItemList.

Правило Лидера: Компания с наивысшим баллом — на 1 месте (Badge "Выбор редакции").

Правило Визуализации (TOP-5 vs REST):

Места 1, 2, 3, 4, 5: Расширенные Premium Карточки (структура ниже). Обязательно используй теги <h3>. Каждая карточка визуально уникальна (асимметрия, разное позиционирование score/метрик).

Места 6+: Компактная таблица (Место | Лого | Название | Год основания | Сайт | Цена от... | Вердикт).

4. Блок "Аналитика рынка" (Deep Content)

График роста цен (Chart.js — загружай async через CDN).

Текстовый анализ "Dealbreakers".

5. SEO-статья (Longread)

Экспертный контент с профессиональной терминологией ниши. Используй отраслевой словарь.

6. FAQ (Вопрос-Ответ)

Разметь этот блок схемой Schema.org/FAQPage.

Вопросы из категории "People Also Ask".

7. Футер и Авторство

Подробная карточка автора (Schema.org/Person).

Политика конфиденциальности.

ДЕТАЛЬНАЯ СТРУКТУРА РАСШИРЕННОЙ КАРТОЧКИ (ТОЛЬКО ДЛЯ TOP-5)

Каждая карточка — это отдельный <article itemscope itemtype="https://schema.org/Product">.

1. Header Карточки

<h3>Название компании</h3> + Бейдж "Верифицировано".

Мета: Локация, Год основания, Парк техники.

CTA Кнопка: "Перейти на сайт" (с атрибутом rel="nofollow"). Кнопка со стилизованным hover-эффектом.

2. Score & AI Summary (Ground Truth)

Общий балл (X.X/10) — визуализирован как кастомный элемент (не просто цифра, а progress ring или styled badge).

AI Summary: Факты, а не вода. Конкретные цифры.

3. Блок "Dealbreakers" (Для AI-Refinements)

Лучше всего подходит для: (конкретные сегменты ЦА).

Может не подойти, если: (конкретные ограничения).

4. Сетка Метрик

Прогресс-бар для каждой метрики из XML (кастомный дизайн, не браузерный <progress>).

Теги преимуществ.

Цены и Условия.

5. Кейс и Отзыв

Кейс: Проблема -> Решение -> Результат.

Отзыв: Цитата с разметкой Schema.org/Review.

ТЕХНИЧЕСКИЕ ТРЕБОВАНИЯ:

1. Микроразметка (Schema.org) — ОБЯЗАТЕЛЬНО

Внедри JSON-LD для: ItemList, Organization (для каждой компании: name, url, aggregateRating), FAQPage, Person, Article.

ПРАВИЛА Schema.org JSON-LD:
- FAQPage: один блок <script type="application/ld+json"> с @type: "FAQPage" и mainEntity: массив Question. НЕ создавай отдельные JSON-LD блоки для каждого Question — они должны быть ТОЛЬКО внутри FAQPage.mainEntity.
- Person: один блок. Если автор упоминается в Article и в Footer — используй @id и ссылайся на него, не дублируй.
- Каждый JSON-LD блок — отдельный <script type="application/ld+json">. Но сущности НЕ дублируются между блоками.

2. Структура и Код (Mobile-First)

Используй семантические теги: <main>, <article>, <section>, <aside>, <time>.

Core Web Vitals: Код должен быть легким. НЕ используй Tailwind — пиши чистый modern CSS с custom properties и CSS Grid/Flexbox. Chart.js (CDN async).

Шрифты: подключи выбранную пару через Google Fonts CDN.

CSS-first анимации. Framer Motion и подобные библиотеки запрещены.

Accessible by default: contrast ratio, focus states, keyboard navigation.

3. Контент (E-E-A-T)

Факты: Используй цифры, проценты, конкретные сроки. Избегай прилагательных "лучший", "качественный" без доказательств.

Словарь: Используй профессиональную терминологию ниши.

4. ВЕСЬ КОД В ОДНОМ HTML-ФАЙЛЕ. Inline styles и scripts допустимы.

5. ЗАЩИТНЫЕ МАРКЕРЫ В <head>:
Добавь в <head> пустые маркеры для внешних счётчиков и мета-тегов:
<!-- PROTECTED:SEO:START --><!-- PROTECTED:SEO:END -->
<!-- PROTECTED:COUNTERS:START --><!-- PROTECTED:COUNTERS:END -->
НЕ помещай свои мета-теги (og:title, description и т.д.) между этими маркерами.
Маркеры должны быть ПОСЛЕ всех твоих мета-тегов и ПЕРЕД </head>.

6. Выведи ТОЛЬКО HTML-код. Без пояснений, без markdown, без тройных бэктиков. Просто чистый HTML начиная с <!DOCTYPE html>.

ВХОДНЫЕ ДАННЫЕ (XML):

${compilerRawXml}`;

        const canvasSection = document.getElementById("canvas-section");
        const canvasLoading = document.getElementById("canvas-loading");
        const canvasToolbar = document.getElementById("canvas-toolbar");
        const canvasPreview = document.getElementById("canvas-preview");
        const canvasCodeView = document.getElementById("canvas-code-view");

        canvasSection.style.display = "block";
        canvasLoading.style.display = "flex";
        canvasToolbar.style.display = "none";
        canvasPreview.style.display = "none";
        canvasCodeView.style.display = "none";
        canvasSection.scrollIntoView({ behavior: "smooth" });

        try {
          const siteData = await callModel("anthropic/claude-sonnet-4.5", [{ role: "user", content: sitePrompt }], apiKey);

          if (siteData.error) {
            canvasLoading.innerHTML = `<div class="error-text" style="padding:20px;">[Ошибка] ${siteData.error}</div>`;
          } else {
            let html = siteData.content;
            html = html.replace(/^```html?\s*\n?/i, '').replace(/\n?```\s*$/i, '').trim();

            canvasRawHtml = html;

            canvasLoading.style.display = "none";
            canvasToolbar.style.display = "flex";
            document.getElementById("editor-toolbar").style.display = "flex";
            canvasPreview.style.display = "block";

            editorActive = false;
            historyStack = [];
            historyIndex = -1;

            const iframe = document.getElementById("canvas-iframe");
            iframe.srcdoc = html;

            const codeContent = document.getElementById("canvas-code-content");
            codeContent.textContent = html;
          }
        } catch (err) {
          canvasLoading.innerHTML = `<div class="error-text" style="padding:20px;">[Ошибка] ${err.message}</div>`;
        }

        updateTimelineStep('step_6', 'done');
        updateProjectStatus('generated', canvasRawHtml);
        updateProjectMeta({ currentStep: 'step_6', compilerRawXml, grokCriteriaRaw, grokAudienceRaw });
      }

      // === STEP 7+8: Perplexity ratings search + download ===
      if (startIdx <= 6) {
        updateTimelineStep('step_7', 'running');

        const ratingsSection = document.getElementById("ratings-section");
        const ratingsLoading = document.getElementById("ratings-loading");
        ratingsSection.style.display = "block";
        ratingsLoading.style.display = "flex";
        document.getElementById('ratings-progress').textContent = '';
        ratingsSection.scrollIntoView({ behavior: "smooth" });

        const perplexityPrompt = `${geoRequestStr ? 'КОНТЕКСТ ЛОКАЦИИ: ' + geoRequestStr + '\n' : ''}ЯЗЫК ОТВЕТА: ${queryLangStr}

Найди 10-15 лучших рейтингов и обзоров компаний по теме "${niche}"${geoStr} в интернете.

Для каждого рейтинга укажи:
- Название статьи/сайта
- Прямой URL страницы рейтинга

Ищи именно страницы-рейтинги, обзоры, сравнения, ТОП-листы — где уже собрана структурированная информация о компаниях данной ниши.

ВАЖНО: Верни ТОЛЬКО JSON-массив и НИЧЕГО больше. Без markdown, без пояснений, без бэктиков.
Формат:
[{"name": "Название рейтинга", "url": "https://..."}]`;

        try {
          const perplexityData = await callModel("perplexity/sonar-pro", [{ role: "user", content: perplexityPrompt }], apiKey);
          ratingsLoading.style.display = "none";

          if (perplexityData.error) {
            document.getElementById('ratings-progress').textContent = `Ошибка Perplexity: ${perplexityData.error}`;
          } else {
            let jsonStr = perplexityData.content.replace(/^```json?\s*\n?/i, '').replace(/\n?```\s*$/i, '').trim();
            const jsonMatch = jsonStr.match(/\[[\s\S]*\]/);
            if (jsonMatch) jsonStr = jsonMatch[0];

            try {
              const ratings = JSON.parse(jsonStr);
              const seenUrls = new Set();
              extractedRatings = ratings.filter(r => {
                if (!r.url) return false;
                try {
                  const domain = new URL(r.url).hostname;
                  if (seenUrls.has(domain)) return false;
                  seenUrls.add(domain);
                  return true;
                } catch { return false; }
              }).map(r => ({ name: r.name, url: r.url, status: 'pending' }));

              renderRatingsGrid();
              updateTimelineStep('step_7', 'done');
              updateTimelineStep('step_8_web', 'running');

              const rQueue = [...extractedRatings.keys()];
              async function processRatingQueue() {
                while (rQueue.length > 0) {
                  const idx = rQueue.shift();
                  await downloadRatingSite(extractedRatings[idx], idx);
                }
              }
              const rWorkers = Array.from(
                { length: Math.min(5, extractedRatings.length) },
                () => processRatingQueue()
              );
              await Promise.all(rWorkers);

            } catch (parseErr) {
              document.getElementById('ratings-progress').textContent = `Ошибка парсинга JSON: ${parseErr.message}. Ответ: ${perplexityData.content.substring(0, 200)}`;
            }
          }
        } catch (err) {
          ratingsLoading.style.display = "none";
          document.getElementById('ratings-progress').textContent = `Ошибка: ${err.message}`;
        }

        // Show fill section
        const fillWrap = document.getElementById("fill-section-wrap");
        if (fillWrap) {
          fillWrap.style.display = "block";
          document.getElementById('fill-btn').disabled = false;
          // Pre-fill company data from project
          const fillData = document.getElementById('fill-company-data');
          if (fillData && project.injection_info) fillData.value = project.injection_info;
          fillWrap.scrollIntoView({ behavior: "smooth" });
        }

        updateTimelineStep('step_8_web', 'done');
        updateProjectMeta({
          currentStep: 'step_8_web',
          compilerRawXml,
          grokCriteriaRaw,
          grokAudienceRaw,
          extractedRatings,
          downloadedRatings
        });
      }

      } catch (pipelineErr) {
        console.error('Pipeline error:', pipelineErr);
        showNotification(`Ошибка пайплайна: ${pipelineErr.message}`, true);
      }

      pipelineRunning = false;
      showNotification('Пайплайн завершён');
    }

    // Restore saved API key
    const savedKey = localStorage.getItem("openrouter_key");
    if (savedKey) document.getElementById("apiKey").value = savedKey;

    // Start SPA router
    router();
  </script>
</body>
</html>
