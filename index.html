<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Поиск лучших компаний по нише</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: #0f1117;
      color: #e1e4e8;
      min-height: 100vh;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 40px 20px;
    }

    h1 {
      text-align: center;
      font-size: 28px;
      margin-bottom: 8px;
      color: #fff;
    }

    .subtitle {
      text-align: center;
      color: #8b949e;
      margin-bottom: 32px;
      font-size: 15px;
    }

    .form-section {
      max-width: 600px;
      margin: 0 auto 40px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .input-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .input-group label {
      font-size: 13px;
      color: #8b949e;
      font-weight: 500;
    }

    input[type="text"], input[type="password"] {
      padding: 12px 16px;
      border: 1px solid #30363d;
      border-radius: 8px;
      background: #161b22;
      color: #e1e4e8;
      font-size: 15px;
      outline: none;
      transition: border-color 0.2s;
    }

    input:focus, select:focus {
      border-color: #58a6ff;
    }

    select {
      padding: 12px 16px;
      border: 1px solid #30363d;
      border-radius: 8px;
      background: #161b22;
      color: #e1e4e8;
      font-size: 15px;
      outline: none;
      transition: border-color 0.2s;
      cursor: pointer;
    }

    .field-hint {
      font-size: 12px;
      color: #888;
      margin-top: 2px;
      line-height: 1.4;
    }

    .prompt-preview {
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 8px;
      padding: 12px 16px;
      font-size: 14px;
      color: #8b949e;
      line-height: 1.6;
    }

    .prompt-preview .highlight {
      color: #58a6ff;
      font-weight: 600;
    }

    button {
      padding: 12px 24px;
      background: #238636;
      color: #fff;
      border: none;
      border-radius: 8px;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s;
    }

    button:hover { background: #2ea043; }
    button:disabled {
      background: #21262d;
      color: #484f58;
      cursor: not-allowed;
    }

    .results {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
      gap: 20px;
    }

    .result-card {
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 12px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .result-header {
      padding: 16px 20px;
      border-bottom: 1px solid #30363d;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .model-badge {
      padding: 4px 10px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 600;
      color: #fff;
    }

    .badge-chatgpt { background: #10a37f; }
    .badge-gemini { background: #4285f4; }
    .badge-claude { background: #d97706; }

    .model-name {
      font-weight: 600;
      font-size: 15px;
    }

    .chat-messages {
      padding: 0;
      max-height: 600px;
      overflow-y: auto;
      flex: 1;
    }

    .chat-messages::-webkit-scrollbar {
      width: 6px;
    }

    .chat-messages::-webkit-scrollbar-thumb {
      background: #30363d;
      border-radius: 3px;
    }

    .chat-msg {
      padding: 14px 20px;
      font-size: 14px;
      line-height: 1.7;
      white-space: pre-wrap;
      border-bottom: 1px solid #1c2129;
    }

    .chat-msg-user {
      background: #1c2333;
    }

    .chat-msg-user .chat-msg-label {
      color: #58a6ff;
      font-weight: 600;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 6px;
    }

    .chat-msg-assistant .chat-msg-label {
      color: #8b949e;
      font-weight: 600;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 6px;
    }

    .error-text { color: #f85149; }

    .chat-input-area {
      display: flex;
      gap: 8px;
      padding: 12px 16px;
      border-top: 1px solid #30363d;
      background: #0d1117;
    }

    .chat-input-area input {
      flex: 1;
      padding: 10px 14px;
      border: 1px solid #30363d;
      border-radius: 8px;
      background: #161b22;
      color: #e1e4e8;
      font-size: 14px;
      outline: none;
    }

    .chat-input-area input:focus {
      border-color: #58a6ff;
    }

    .chat-input-area button {
      padding: 10px 16px;
      font-size: 13px;
      white-space: nowrap;
    }

    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 40px;
      color: #8b949e;
    }

    .spinner {
      width: 20px;
      height: 20px;
      border: 2px solid #30363d;
      border-top-color: #58a6ff;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    .spinner-small {
      width: 14px;
      height: 14px;
      border: 2px solid #30363d;
      border-top-color: #58a6ff;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      display: inline-block;
    }

    @keyframes spin { to { transform: rotate(360deg); } }

    .grok-table-wrap table {
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
    }

    .grok-table-wrap th {
      background: #1c2333;
      color: #58a6ff;
      text-align: left;
      padding: 10px 14px;
      border: 1px solid #30363d;
      font-weight: 600;
    }

    .grok-table-wrap td {
      padding: 10px 14px;
      border: 1px solid #30363d;
      line-height: 1.5;
    }

    .grok-table-wrap tr:nth-child(even) {
      background: #161b22;
    }

    .grok-table-wrap tr:nth-child(odd) {
      background: #0d1117;
    }

    .xml-output {
      background: #0d1117;
      border: 1px solid #30363d;
      border-radius: 8px;
      padding: 20px;
      font-family: "SF Mono", "Fira Code", "Consolas", monospace;
      font-size: 13px;
      line-height: 1.7;
      white-space: pre-wrap;
      word-break: break-word;
      overflow-x: auto;
      color: #e1e4e8;
    }

    .xml-output .xml-tag { color: #7ee787; }
    .xml-output .xml-attr { color: #d2a8ff; }
    .xml-output .xml-val { color: #a5d6ff; }
    .xml-output .xml-text { color: #e1e4e8; }

    .copy-btn {
      padding: 6px 14px;
      font-size: 12px;
      background: #21262d;
      color: #8b949e;
      border: 1px solid #30363d;
      border-radius: 6px;
      cursor: pointer;
      float: right;
      margin-bottom: 10px;
    }

    .copy-btn:hover {
      background: #30363d;
      color: #e1e4e8;
    }

    .canvas-toolbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 16px;
      border-bottom: 1px solid #30363d;
      background: #0d1117;
    }

    .canvas-tabs {
      display: flex;
      gap: 4px;
    }

    .canvas-tab {
      padding: 6px 16px;
      font-size: 13px;
      background: transparent;
      color: #8b949e;
      border: 1px solid transparent;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 500;
    }

    .canvas-tab:hover {
      color: #e1e4e8;
      background: #161b22;
    }

    .canvas-tab.active {
      background: #238636;
      color: #fff;
      border-color: #238636;
    }

    .canvas-frame {
      width: 100%;
      min-height: 800px;
      border: none;
      background: #fff;
      border-radius: 0 0 12px 12px;
    }

    .canvas-code {
      background: #0d1117;
      padding: 20px;
      font-family: "SF Mono", "Fira Code", "Consolas", monospace;
      font-size: 12px;
      line-height: 1.6;
      color: #e1e4e8;
      overflow-x: auto;
      white-space: pre-wrap;
      word-break: break-word;
      max-height: 800px;
      overflow-y: auto;
      margin: 0;
    }

    .companies-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 10px;
      margin-bottom: 20px;
    }

    .company-btn {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px 14px;
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 8px;
      color: #e1e4e8;
      font-size: 13px;
      cursor: pointer;
      transition: border-color 0.2s, background 0.2s;
      text-align: left;
      width: 100%;
    }

    .company-btn:hover { border-color: #58a6ff; background: #1c2333; }
    .company-btn.status-done { border-color: #238636; }
    .company-btn.status-error { border-color: #f85149; }
    .company-btn.status-loading { border-color: #d29922; }

    .company-status-icon {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .company-status-icon.pending { background: #484f58; }
    .company-status-icon.loading { background: #d29922; animation: pulse 1s infinite; }
    .company-status-icon.done { background: #238636; }
    .company-status-icon.error { background: #f85149; }

    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }

    .company-preview-frame {
      width: 100%;
      height: 500px;
      border: 1px solid #30363d;
      border-radius: 8px;
      background: #fff;
    }

    .fill-section {
      margin-top: 20px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .fill-section textarea {
      width: 100%;
      min-height: 120px;
      padding: 12px 16px;
      border: 1px solid #30363d;
      border-radius: 8px;
      background: #161b22;
      color: #e1e4e8;
      font-size: 14px;
      font-family: inherit;
      resize: vertical;
      outline: none;
    }

    .fill-section textarea:focus { border-color: #58a6ff; }
    .fill-section textarea::placeholder { color: #484f58; }

    .download-progress {
      font-size: 13px;
      color: #8b949e;
      margin-bottom: 8px;
    }

    .api-key-toggle {
      font-size: 12px;
      color: #58a6ff;
      cursor: pointer;
      background: none;
      border: none;
      padding: 0;
      font-weight: 400;
    }

    .api-key-toggle:hover {
      text-decoration: underline;
      background: none;
    }

    /* --- Editor toolbar --- */
    .editor-toolbar {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 16px;
      background: #161b22;
      border-bottom: 1px solid #30363d;
      flex-wrap: wrap;
    }

    .editor-toggle {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 13px;
      color: #8b949e;
      cursor: pointer;
      user-select: none;
    }

    .editor-toggle input[type="checkbox"] {
      accent-color: #238636;
      width: 16px;
      height: 16px;
    }

    .editor-btn {
      padding: 4px 12px;
      font-size: 12px;
      background: #21262d;
      color: #8b949e;
      border: 1px solid #30363d;
      border-radius: 6px;
      cursor: pointer;
    }

    .editor-btn:hover:not(:disabled) {
      background: #30363d;
      color: #e1e4e8;
    }

    .editor-btn:disabled {
      opacity: 0.4;
      cursor: default;
    }

    .editor-btn-primary {
      background: #238636;
      color: #fff;
      border-color: #238636;
    }

    .editor-btn-primary:hover {
      background: #2ea043;
    }

    /* --- SEO Panel --- */
    .seo-panel {
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 12px;
      padding: 20px;
      margin-top: 16px;
      display: none;
    }

    .seo-panel h3 {
      font-size: 16px;
      color: #e1e4e8;
      margin-bottom: 16px;
    }

    .seo-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }

    .seo-field {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .seo-field.full-width {
      grid-column: 1 / -1;
    }

    .seo-field label {
      font-size: 13px;
      color: #8b949e;
      font-weight: 500;
    }

    .seo-field input,
    .seo-field textarea {
      background: #0d1117;
      border: 1px solid #30363d;
      border-radius: 6px;
      color: #e1e4e8;
      padding: 8px 12px;
      font-size: 13px;
      font-family: inherit;
    }

    .seo-field textarea {
      min-height: 60px;
      resize: vertical;
    }

    .seo-field .field-hint {
      color: #6e7681;
      font-size: 11px;
    }

    .seo-actions {
      margin-top: 12px;
      display: flex;
      gap: 8px;
      justify-content: flex-end;
    }

    .seo-notification {
      position: fixed;
      bottom: 24px;
      right: 24px;
      background: #238636;
      color: #fff;
      padding: 10px 20px;
      border-radius: 8px;
      font-size: 13px;
      z-index: 10000;
      animation: fadeInOut 2.5s ease forwards;
    }

    @keyframes fadeInOut {
      0% { opacity: 0; transform: translateY(10px); }
      15% { opacity: 1; transform: translateY(0); }
      80% { opacity: 1; }
      100% { opacity: 0; }
    }

    /* Projects list */
    .projects-section {
      margin-bottom: 32px;
      border: 1px solid #30363d;
      border-radius: 12px;
      background: #161b22;
      overflow: hidden;
    }
    .projects-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 20px;
      background: #1c2128;
      border-bottom: 1px solid #30363d;
      cursor: pointer;
    }
    .projects-header h2 {
      font-size: 16px;
      color: #fff;
      margin: 0;
    }
    .projects-header .toggle-arrow {
      color: #8b949e;
      font-size: 14px;
      transition: transform 0.2s;
    }
    .projects-header .toggle-arrow.open {
      transform: rotate(180deg);
    }
    .projects-list {
      padding: 12px;
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 12px;
      max-height: 400px;
      overflow-y: auto;
    }
    .projects-list:empty::after {
      content: 'Нет сохранённых проектов';
      color: #8b949e;
      font-size: 13px;
      padding: 20px;
      text-align: center;
      grid-column: 1 / -1;
    }
    .project-card {
      background: #0d1117;
      border: 1px solid #30363d;
      border-radius: 8px;
      padding: 14px;
      transition: border-color 0.2s;
    }
    .project-card:hover {
      border-color: #58a6ff;
    }
    .project-card .pc-niche {
      font-size: 15px;
      font-weight: 600;
      color: #fff;
      margin-bottom: 4px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .project-card .pc-geo {
      font-size: 12px;
      color: #8b949e;
      margin-bottom: 8px;
    }
    .project-card .pc-meta {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    .project-card .pc-date {
      font-size: 11px;
      color: #6e7681;
    }
    .project-card .pc-status {
      font-size: 11px;
      padding: 2px 8px;
      border-radius: 10px;
      font-weight: 500;
    }
    .pc-status.in_progress { background: #1f2d3d; color: #58a6ff; }
    .pc-status.generated { background: #1a2e1a; color: #3fb950; }
    .pc-status.filled { background: #2d1f3d; color: #bc8cff; }
    .pc-status.edited { background: #2d2a1f; color: #d29922; }
    .project-card .pc-actions {
      display: flex;
      gap: 6px;
    }
    .project-card .pc-actions button {
      flex: 1;
      padding: 5px 8px;
      font-size: 11px;
      border: 1px solid #30363d;
      border-radius: 6px;
      background: #21262d;
      color: #c9d1d9;
      cursor: pointer;
      transition: background 0.15s;
    }
    .project-card .pc-actions button:hover {
      background: #30363d;
    }
    .project-card .pc-actions button.pc-open {
      background: #238636;
      border-color: #238636;
      color: #fff;
    }
    .project-card .pc-actions button.pc-open:hover {
      background: #2ea043;
    }
    .project-card .pc-actions button.pc-delete:hover {
      background: #da3633;
      border-color: #da3633;
      color: #fff;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>30 лучших компаний по нише</h1>
    <p class="subtitle">Введите нишу — получите списки от трёх нейросетей через OpenRouter</p>

    <div class="projects-section" id="projects-section">
      <div class="projects-header" onclick="toggleProjectsList()">
        <h2>Мои проекты <span id="projects-count" style="color:#8b949e; font-weight:400;"></span></h2>
        <span class="toggle-arrow" id="projects-arrow">▼</span>
      </div>
      <div class="projects-list" id="projects-list" style="display:none;"></div>
    </div>

    <div class="form-section">
      <div class="input-group">
        <label>
          API-ключ OpenRouter
          <button class="api-key-toggle" onclick="toggleApiKey()" id="toggleBtn">показать</button>
        </label>
        <input type="password" id="apiKey" placeholder="sk-or-..." />
      </div>

      <div class="input-group">
        <label>Название ниши</label>
        <input type="text" id="niche" placeholder="например: кибербезопасность" oninput="updatePreview()" />
        <span class="field-hint">Укажите нишу или тематику для поиска компаний. Пример: аренда авто, кибербезопасность</span>
      </div>

      <div class="input-group">
        <label>Гео ниши <span style="color:#8b949e; font-weight:400;">(необязательно)</span></label>
        <input type="text" id="geo" placeholder="например: Москва, Россия, Казахстан..." oninput="updatePreview()" />
        <span class="field-hint">Где работают компании. Оставьте пустым для глобального поиска. Пример: Калифорния, Москва</span>
      </div>

      <div class="input-group">
        <label>Гео запроса <span style="color:#8b949e; font-weight:400;">(необязательно)</span></label>
        <input type="text" id="geoRequest" placeholder="например: Москва, New York..." />
        <span class="field-hint">Откуда вы ищете — влияет на релевантность выдачи с учётом вашей локации. Пример: Москва, New York</span>
      </div>

      <div class="input-group">
        <label>Язык запросов</label>
        <select id="queryLang">
          <option value="Русский">Русский</option>
          <option value="English">English</option>
          <option value="Deutsch">Deutsch</option>
          <option value="Français">Français</option>
          <option value="Español">Español</option>
          <option value="中文">中文</option>
          <option value="日本語">日本語</option>
        </select>
        <span class="field-hint">На каком языке модели будут искать и анализировать компании</span>
      </div>

      <div class="input-group">
        <label>Язык сайта</label>
        <select id="siteLang">
          <option value="Русский">Русский</option>
          <option value="English">English</option>
          <option value="Deutsch">Deutsch</option>
          <option value="Français">Français</option>
          <option value="Español">Español</option>
          <option value="中文">中文</option>
          <option value="日本語">日本語</option>
        </select>
        <span class="field-hint">На каком языке будет сгенерирован итоговый рейтинговый сайт</span>
      </div>

      <div class="prompt-preview" id="preview">
        Составь список 30 <span class="highlight">...</span>
      </div>

      <div style="display:flex; gap:8px;">
        <button id="searchBtn" onclick="search()" style="flex:1;">Найти компании</button>
        <button class="copy-btn" onclick="clearSavedState()" style="float:none; margin:0; padding:10px 14px; font-size:13px;" title="Очистить сохранённый кеш результатов">Очистить кеш</button>
      </div>

      <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #30363d; display:flex; justify-content:space-between; align-items:center;">
        <details style="flex:1;">
          <summary style="cursor:pointer; font-size:13px; color:#8b949e;">Быстрый тест загрузки</summary>
          <div style="margin-top: 8px; display:flex; gap:8px;">
            <input type="text" id="testUrl" placeholder="https://example.com" style="flex:1;" />
            <button onclick="testDownload()" style="white-space:nowrap;">Тест</button>
          </div>
          <div id="testResult" style="margin-top:8px; font-size:12px; color:#8b949e; white-space:pre-wrap;"></div>
        </details>
        <a href="test-download.html" style="font-size:13px; color:#58a6ff; text-decoration:none; margin-left:12px;">Полный тест скачивания →</a>
      </div>
    </div>

    <div class="results" id="results"></div>

    <div id="grok-section" style="display:none; margin-top: 40px;">
      <h2 style="text-align:center; font-size:22px; margin-bottom:16px; color:#fff;">Итоговый анализ — Grok Deep Research</h2>
      <div class="result-card" id="grok-card">
        <div class="result-header">
          <span class="model-badge" style="background:#ef4444;">Grok</span>
          <span class="model-name">Grok Deep Research</span>
        </div>
        <div class="chat-messages" id="grok-messages"></div>
      </div>
    </div>

    <div id="audience-section" style="display:none; margin-top: 40px;">
      <h2 style="text-align:center; font-size:22px; margin-bottom:16px; color:#fff;">Аудитории и боли — Grok</h2>
      <div class="result-card" id="audience-card">
        <div class="result-header">
          <span class="model-badge" style="background:#ef4444;">Grok</span>
          <span class="model-name">Аудитории и боли ЦА</span>
        </div>
        <div class="chat-messages" id="audience-messages"></div>
      </div>
    </div>

    <div id="compiler-section" style="display:none; margin-top: 40px;">
      <h2 style="text-align:center; font-size:22px; margin-bottom:16px; color:#fff;">Компилятор критериев — Claude</h2>
      <div class="result-card" id="compiler-card">
        <div class="result-header">
          <span class="model-badge badge-claude">Claude</span>
          <span class="model-name">XML-структура критериев</span>
        </div>
        <div class="chat-messages" id="compiler-messages" style="max-height:none;"></div>
      </div>
    </div>

    <div id="canvas-section" style="display:none; margin-top: 40px;">
      <h2 style="text-align:center; font-size:22px; margin-bottom:16px; color:#fff;">Генератор сайта — Claude</h2>
      <div class="result-card" id="canvas-card">
        <div class="result-header">
          <span class="model-badge badge-claude">Claude</span>
          <span class="model-name">Готовый сайт (HTML)</span>
        </div>
        <div class="canvas-toolbar" id="canvas-toolbar" style="display:none;">
          <div class="canvas-tabs">
            <button class="canvas-tab active" onclick="switchCanvasTab('preview')">Превью</button>
            <button class="canvas-tab" onclick="switchCanvasTab('code')">Код</button>
          </div>
          <button class="copy-btn" onclick="navigator.clipboard.writeText(canvasRawHtml).then(()=>{this.textContent='Скопировано!';setTimeout(()=>this.textContent='Копировать HTML',1500)})">Копировать HTML</button>
        </div>
        <!-- Editor toolbar -->
        <div class="editor-toolbar" id="editor-toolbar" style="display:none;">
          <label class="editor-toggle">
            <input type="checkbox" id="editor-mode-toggle" onchange="toggleEditorMode(this.checked)">
            Режим редактирования
          </label>
          <button class="editor-btn" id="undo-btn" onclick="editorUndo()" disabled style="display:none;">↩ Отменить</button>
          <button class="editor-btn" id="redo-btn" onclick="editorRedo()" disabled style="display:none;">↪ Повторить</button>
          <div style="flex:1;"></div>
          <button class="editor-btn" id="seo-panel-toggle" onclick="toggleSeoPanel()">SEO и счётчики</button>
          <button class="editor-btn editor-btn-primary" onclick="openInEditor()">Открыть в редакторе</button>
          <button class="editor-btn editor-btn-primary" id="download-html-btn" onclick="downloadHtml()">Скачать HTML</button>
        </div>
        <div id="canvas-loading" class="loading" style="display:none;"><div class="spinner"></div>Claude генерирует сайт...</div>
        <div id="canvas-preview" style="display:none;">
          <iframe id="canvas-iframe" class="canvas-frame" sandbox="allow-scripts allow-same-origin"></iframe>
        </div>
        <div id="canvas-code-view" style="display:none;">
          <pre class="canvas-code"><code id="canvas-code-content"></code></pre>
        </div>
      </div>

      <!-- SEO & Counters Panel -->
      <div class="seo-panel" id="seo-panel">
        <h3>SEO и счётчики</h3>
        <div class="seo-grid">
          <div class="seo-field">
            <label for="counterYandex">Яндекс.Метрика</label>
            <textarea id="counterYandex" placeholder="Вставьте полный код счётчика"></textarea>
            <span class="field-hint">Вставьте полный код счётчика из Яндекс.Метрики (включая &lt;script&gt; теги)</span>
          </div>
          <div class="seo-field">
            <label for="counterGoogle">Google Analytics / GTM</label>
            <textarea id="counterGoogle" placeholder="Вставьте код GA или GTM"></textarea>
            <span class="field-hint">Вставьте код Google Analytics или Google Tag Manager (включая &lt;script&gt; теги)</span>
          </div>
          <div class="seo-field">
            <label for="metaYandex">Яндекс.Вебмастер</label>
            <input type="text" id="metaYandex" placeholder="yandex-verification значение">
            <span class="field-hint">Значение meta-тега yandex-verification (только значение, без HTML)</span>
          </div>
          <div class="seo-field">
            <label for="metaGoogle">Google Search Console</label>
            <input type="text" id="metaGoogle" placeholder="google-site-verification значение">
            <span class="field-hint">Значение meta-тега google-site-verification (только значение, без HTML)</span>
          </div>
          <div class="seo-field">
            <label for="metaTitle">Title</label>
            <input type="text" id="metaTitle" placeholder="Заголовок страницы">
            <span class="field-hint">Заголовок страницы для поисковых систем</span>
          </div>
          <div class="seo-field">
            <label for="metaDesc">Description</label>
            <textarea id="metaDesc" placeholder="Описание страницы (до 160 символов)"></textarea>
            <span class="field-hint">Описание страницы для поисковых систем (рекомендуется до 160 символов)</span>
          </div>
          <div class="seo-field">
            <label for="metaKeywords">Keywords</label>
            <input type="text" id="metaKeywords" placeholder="Ключевые слова через запятую">
            <span class="field-hint">Ключевые слова через запятую</span>
          </div>
          <div class="seo-field">
            <label for="metaOgImage">OG Image URL</label>
            <input type="text" id="metaOgImage" placeholder="https://example.com/image.jpg">
            <span class="field-hint">Прямая ссылка на изображение для соцсетей (Open Graph)</span>
          </div>
        </div>
        <div class="seo-actions">
          <button class="editor-btn editor-btn-primary" onclick="applySeoCounters()">Применить</button>
        </div>
      </div>
    </div>

    <div id="ratings-section" style="display:none; margin-top: 40px;">
      <h2 style="text-align:center; font-size:22px; margin-bottom:16px; color:#fff;">Поиск рейтингов в интернете</h2>
      <div class="result-card" id="ratings-card">
        <div class="result-header">
          <span class="model-badge" style="background:#20b2aa;">Perplexity</span>
          <span class="model-name">Поиск рейтинговых сайтов</span>
        </div>
        <div style="padding: 20px;">
          <div id="ratings-loading" class="loading" style="display:none;"><div class="spinner"></div>Perplexity ищет рейтинги...</div>
          <div class="download-progress" id="ratings-progress"></div>
          <div class="companies-grid" id="ratings-grid"></div>
          <div id="rating-preview-wrap" style="display:none; margin-top: 16px;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
              <span id="rating-preview-title" style="font-size:14px; color:#58a6ff; font-weight:600;"></span>
              <button class="copy-btn" onclick="document.getElementById('rating-preview-wrap').style.display='none'">Закрыть</button>
            </div>
            <iframe id="rating-preview-iframe" class="company-preview-frame" sandbox="allow-scripts allow-same-origin"></iframe>
          </div>
        </div>
      </div>
    </div>

    <div id="sites-section" style="display:none; margin-top: 40px;">
      <h2 style="text-align:center; font-size:22px; margin-bottom:16px; color:#fff;">Загрузка сайтов компаний</h2>
      <div class="result-card" id="sites-card">
        <div class="result-header">
          <span class="model-badge" style="background:#8b5cf6;">Web</span>
          <span class="model-name">Скачивание сайтов TOP-5 компаний</span>
        </div>
        <div style="padding: 20px;">
          <div class="download-progress" id="download-progress">Извлечение списка компаний...</div>
          <div class="companies-grid" id="companies-grid"></div>
          <div id="company-preview-wrap" style="display:none; margin-top: 16px;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
              <span id="company-preview-title" style="font-size:14px; color:#58a6ff; font-weight:600;"></span>
              <button class="copy-btn" onclick="document.getElementById('company-preview-wrap').style.display='none'">Закрыть</button>
            </div>
            <iframe id="company-preview-iframe" class="company-preview-frame" sandbox="allow-scripts allow-same-origin"></iframe>
          </div>
          <div class="fill-section">
            <label style="font-size:13px; color:#8b949e; font-weight:500;">Данные вашей компании (она станет #1 в рейтинге)</label>
            <textarea id="user-company-data" placeholder="Название компании, описание услуг, преимущества, цены, отзывы клиентов..."></textarea>
            <button id="fill-btn" onclick="fillTemplate()" disabled>Наполнить контентом</button>
          </div>
          <div id="fill-loading" class="loading" style="display:none;">
            <div class="spinner"></div>Claude наполняет сайт реальными данными...
          </div>
        </div>
      </div>
    </div>

  </div>

  <script>
    // === Projects: localStorage ===
    let currentProjectId = null;
    const PROJECTS_KEY = 'nrg_projects';

    const STATUS_LABELS = {
      in_progress: 'Генерация',
      generated: 'Сгенерирован',
      filled: 'Наполнен',
      edited: 'Отредактирован'
    };

    function getProjects() {
      try { return JSON.parse(localStorage.getItem(PROJECTS_KEY) || '[]'); }
      catch { return []; }
    }

    function saveProjects(projects) {
      localStorage.setItem(PROJECTS_KEY, JSON.stringify(projects));
    }

    function loadProjects() {
      const projects = getProjects();
      const list = document.getElementById('projects-list');
      const count = document.getElementById('projects-count');
      count.textContent = projects.length > 0 ? `(${projects.length})` : '';

      list.innerHTML = projects.map(p => `
        <div class="project-card" data-id="${p.id}">
          <div class="pc-niche">${escHtml(p.niche)}</div>
          <div class="pc-geo">${p.geo ? escHtml(p.geo) : 'Глобальный'}</div>
          <div class="pc-meta">
            <span class="pc-date">${new Date(p.created_at).toLocaleDateString('ru-RU', { day: 'numeric', month: 'short', year: 'numeric', hour: '2-digit', minute: '2-digit' })}</span>
            <span class="pc-status ${p.status}">${STATUS_LABELS[p.status] || p.status}</span>
          </div>
          <div class="pc-actions">
            <button class="pc-open" onclick="openProject('${p.id}')">Открыть</button>
            <button onclick="duplicateProject('${p.id}')">Дубл.</button>
            <button class="pc-delete" onclick="deleteProject('${p.id}')">Удалить</button>
          </div>
        </div>
      `).join('');
    }

    function escHtml(str) {
      const d = document.createElement('div');
      d.textContent = str;
      return d.innerHTML;
    }

    function toggleProjectsList() {
      const list = document.getElementById('projects-list');
      const arrow = document.getElementById('projects-arrow');
      const isHidden = list.style.display === 'none';
      list.style.display = isHidden ? 'grid' : 'none';
      arrow.classList.toggle('open', isHidden);
      if (isHidden) loadProjects();
    }

    function createProject() {
      const niche = document.getElementById('niche').value.trim();
      const geo = document.getElementById('geo').value.trim() || null;
      const geoRequest = document.getElementById('geoRequest').value.trim() || null;
      const queryLang = document.getElementById('queryLang').value;
      const siteLang = document.getElementById('siteLang').value;
      const userCompanyData = document.getElementById('user-company-data')?.value.trim() || '';

      let injectionName = null, injectionUrl = null, injectionInfo = null;
      if (userCompanyData) {
        injectionInfo = userCompanyData;
        const lines = userCompanyData.split('\n');
        if (lines[0]) injectionName = lines[0].trim();
        const urlMatch = userCompanyData.match(/https?:\/\/[^\s]+/);
        if (urlMatch) injectionUrl = urlMatch[0];
      }

      const id = crypto.randomUUID();
      const project = {
        id, created_at: new Date().toISOString(), updated_at: new Date().toISOString(),
        niche, geo, geo_request: geoRequest, query_lang: queryLang, site_lang: siteLang,
        injection_name: injectionName, injection_url: injectionUrl, injection_info: injectionInfo,
        status: 'in_progress', html_content: null, seo_block: null, counters_block: null, meta: {}
      };

      const projects = getProjects();
      projects.unshift(project);
      saveProjects(projects);
      currentProjectId = id;
      return id;
    }

    function updateProjectMeta(meta) {
      if (!currentProjectId) return;
      const projects = getProjects();
      const p = projects.find(p => p.id === currentProjectId);
      if (!p) return;
      p.meta = { ...p.meta, ...meta };
      p.updated_at = new Date().toISOString();
      saveProjects(projects);
    }

    function updateProjectStatus(status, htmlContent) {
      if (!currentProjectId) return;
      const projects = getProjects();
      const p = projects.find(p => p.id === currentProjectId);
      if (!p) return;
      p.status = status;
      p.updated_at = new Date().toISOString();
      if (htmlContent !== undefined) p.html_content = htmlContent;
      saveProjects(projects);
    }

    function updateProjectHtml(htmlContent, seoBlock, countersBlock) {
      if (!currentProjectId) return;
      const projects = getProjects();
      const p = projects.find(p => p.id === currentProjectId);
      if (!p) return;
      p.html_content = htmlContent;
      p.updated_at = new Date().toISOString();
      if (seoBlock !== undefined) p.seo_block = seoBlock;
      if (countersBlock !== undefined) p.counters_block = countersBlock;
      saveProjects(projects);
    }

    function openProject(id) {
      const projects = getProjects();
      const data = projects.find(p => p.id === id);
      if (!data) { alert('Проект не найден'); return; }

      currentProjectId = data.id;

      // Restore form fields
      document.getElementById('niche').value = data.niche || '';
      document.getElementById('geo').value = data.geo || '';
      document.getElementById('geoRequest').value = data.geo_request || '';
      document.getElementById('queryLang').value = data.query_lang || 'Русский';
      document.getElementById('siteLang').value = data.site_lang || 'Русский';
      if (data.injection_info) {
        document.getElementById('user-company-data').value = data.injection_info;
      }

      // Restore pipeline state from meta
      if (data.meta) {
        if (data.meta.extractedCompanies) extractedCompanies = data.meta.extractedCompanies;
        if (data.meta.extractedRatings) extractedRatings = data.meta.extractedRatings;
        if (data.meta.compilerRawXml) compilerRawXml = data.meta.compilerRawXml;
      }

      // Restore HTML content
      if (data.html_content) {
        canvasRawHtml = data.html_content;
        const canvasSection = document.getElementById('canvas-section');
        if (canvasSection) {
          canvasSection.style.display = 'block';
          const iframe = canvasSection.querySelector('iframe');
          if (iframe) iframe.srcdoc = canvasRawHtml;
        }

        // Restore SEO and counters blocks
        if (data.seo_block) {
          const seoFields = ['counterYandex','counterGoogle','metaYandex','metaGoogle','metaTitle','metaDesc','metaKeywords','metaOgImage'];
          try {
            const seoData = JSON.parse(data.seo_block);
            seoFields.forEach(f => {
              const el = document.getElementById(f);
              if (el && seoData[f]) el.value = seoData[f];
            });
          } catch(e) {}
        }

        // Show editor toolbar
        const toolbar = document.getElementById('editor-toolbar');
        if (toolbar) toolbar.style.display = 'flex';
        document.getElementById('fill-btn')?.removeAttribute('disabled');
      }

      // Show relevant sections
      if (data.meta?.currentStep) {
        const sitesSection = document.getElementById('sites-section');
        if (sitesSection && (data.meta.currentStep === 'step_8_web' || data.status !== 'in_progress')) {
          sitesSection.style.display = 'block';
        }
      }

      updatePreview();
      if (data.status === 'in_progress' && data.meta?.currentStep) {
        showNotification(`Проект загружен. Остановлен на: ${data.meta.currentStep}`);
      } else {
        showNotification('Проект загружен');
      }
    }

    function duplicateProject(id) {
      const projects = getProjects();
      const orig = projects.find(p => p.id === id);
      if (!orig) return;

      const copy = JSON.parse(JSON.stringify(orig));
      copy.id = crypto.randomUUID();
      copy.created_at = new Date().toISOString();
      copy.updated_at = new Date().toISOString();
      copy.niche = copy.niche + ' (копия)';
      copy.status = 'in_progress';

      projects.unshift(copy);
      saveProjects(projects);
      loadProjects();
      showNotification('Проект дублирован');
    }

    function deleteProject(id) {
      if (!confirm('Удалить проект? Это действие необратимо.')) return;

      let projects = getProjects();
      projects = projects.filter(p => p.id !== id);
      saveProjects(projects);

      if (currentProjectId === id) currentProjectId = null;
      loadProjects();
      showNotification('Проект удалён');
    }

    const MODELS = [
      { id: "openai/gpt-5", name: "ChatGPT (GPT-5)" },
      { id: "google/gemini-3-pro-preview", name: "Gemini 3 Pro" },
      { id: "anthropic/claude-sonnet-4.5", name: "Claude (Sonnet 4.5)" },
    ];

    // Conversation history per model: { [modelId]: [{role, content}] }
    const conversations = {};

    // Direct OpenRouter call (no backend needed)
    async function callModel(modelId, messages, apiKey) {
      const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${apiKey}`,
        },
        body: JSON.stringify({ model: modelId, messages }),
      });

      if (!response.ok) {
        const err = await response.text();
        return { error: `Ошибка API: ${response.status} — ${err}` };
      }

      const data = await response.json();
      const content = data.choices?.[0]?.message?.content || "Пустой ответ";
      return { content };
    }

    function mdTableToHtml(text) {
      const lines = text.split("\n").map(l => l.trim()).filter(l => l.startsWith("|"));
      if (lines.length < 2) return null;

      const parseRow = line => line.split("|").slice(1, -1).map(c => c.trim());

      const headers = parseRow(lines[0]);
      // skip separator line (line with ---)
      const startIdx = lines[1].includes("---") ? 2 : 1;
      const rows = lines.slice(startIdx).map(parseRow);

      let html = "<table><thead><tr>";
      for (const h of headers) html += `<th>${h}</th>`;
      html += "</tr></thead><tbody>";
      for (const row of rows) {
        html += "<tr>";
        for (const cell of row) html += `<td>${cell}</td>`;
        html += "</tr>";
      }
      html += "</tbody></table>";
      return html;
    }

    // Parse audience response: always produce 2-column table + portraits block
    function parseAudienceResponse(text) {
      const lines = text.split("\n").map(l => l.trim()).filter(l => l.startsWith("|"));
      if (lines.length < 3) return null;

      const parseRow = line => line.split("|").slice(1, -1).map(c => c.trim());
      const headers = parseRow(lines[0]);
      const startIdx = lines[1].includes("---") ? 2 : 1;
      const dataRows = lines.slice(startIdx).map(parseRow);

      const colCount = headers.length;

      // Determine which columns are ЦА and Боль/Интент
      // If 3+ columns: first = ЦА, last = Боль, middle = Портрет
      const caIdx = 0;
      const painIdx = colCount - 1;
      const portraitIdx = colCount >= 3 ? 1 : -1;

      // Build 2-column table
      let tableHtml = `<table><thead><tr><th>ЦА</th><th>Боль / Интент</th></tr></thead><tbody>`;
      const portraits = {};

      for (const row of dataRows) {
        const ca = row[caIdx] || "";
        const pain = row[painIdx] || "";
        tableHtml += `<tr><td>${ca}</td><td>${pain}</td></tr>`;

        // Collect unique portraits
        if (portraitIdx >= 0 && row[portraitIdx] && ca && !portraits[ca]) {
          portraits[ca] = row[portraitIdx];
        }
      }
      tableHtml += "</tbody></table>";

      // Build portraits HTML
      let portraitsHtml = "";
      const entries = Object.entries(portraits);
      if (entries.length > 0) {
        portraitsHtml = `<div style="margin-top:20px; padding-top:16px; border-top:1px solid #30363d;">
          <div style="font-size:12px; color:#58a6ff; font-weight:600; text-transform:uppercase; letter-spacing:0.5px; margin-bottom:12px;">Портреты ЦА</div>`;
        for (const [name, desc] of entries) {
          portraitsHtml += `<div style="margin-bottom:8px; font-size:14px; line-height:1.6;"><span style="color:#e1e4e8; font-weight:600;">${name}:</span> <span style="color:#8b949e;">${desc}</span></div>`;
        }
        portraitsHtml += "</div>";
      }

      return { tableHtml, portraitsHtml };
    }

    // XML syntax highlighter
    function highlightXml(text) {
      // Strip markdown code fences if present
      text = text.replace(/^```xml\s*\n?/i, '').replace(/\n?```\s*$/i, '').trim();
      return text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/&lt;(\/?[\w_]+)(.*?)&gt;/g, (match, tag, rest) => {
          // Highlight attributes inside tags
          const highlighted = rest.replace(/([\w_]+)=(&quot;|")(.*?)(&quot;|")/g,
            '<span class="xml-attr">$1</span>=<span class="xml-val">"$3"</span>');
          return `<span class="xml-tag">&lt;${tag}${highlighted}&gt;</span>`;
        });
    }

    let compilerRawXml = ""; // Store for copy button
    let canvasRawHtml = ""; // Store for copy button
    let extractedCompanies = []; // [{name, url, status, errorReason}]
    let downloadedSites = {};    // {name: {html, text}}
    let extractedRatings = [];   // [{name, url, status, errorReason}]
    let downloadedRatings = {};  // {name: {html, text}}

    // =============================================
    // localStorage — save / load pipeline state
    // =============================================
    const LS_KEY = 'niche_rating_state';

    function saveState() {
      try {
        const state = {
          ts: Date.now(),
          niche: document.getElementById('niche')?.value || '',
          geo: document.getElementById('geo')?.value || '',
          apiKey: document.getElementById('apiKey')?.value || '',
          geoRequest: document.getElementById('geoRequest')?.value || '',
          queryLang: document.getElementById('queryLang')?.value || '',
          siteLang: document.getElementById('siteLang')?.value || '',
          conversations: conversations,
          compilerRawXml,
          canvasRawHtml,
          extractedCompanies,
          extractedRatings,
          downloadedSites,
          downloadedRatings,
          // Section innerHTML for visual restore
          sections: {
            results: document.getElementById('results')?.innerHTML || '',
            grokMessages: document.getElementById('grok-messages')?.innerHTML || '',
            audienceMessages: document.getElementById('audience-messages')?.innerHTML || '',
            compilerMessages: document.getElementById('compiler-messages')?.innerHTML || '',
          },
          // Which sections are visible
          visibility: {
            results: document.getElementById('results')?.innerHTML ? true : false,
            grok: document.getElementById('grok-section')?.style.display !== 'none',
            audience: document.getElementById('audience-section')?.style.display !== 'none',
            compiler: document.getElementById('compiler-section')?.style.display !== 'none',
            canvas: document.getElementById('canvas-section')?.style.display !== 'none',
            ratings: document.getElementById('ratings-section')?.style.display !== 'none',
            sites: document.getElementById('sites-section')?.style.display !== 'none',
          },
          userCompanyData: document.getElementById('user-company-data')?.value || '',
        };
        localStorage.setItem(LS_KEY, JSON.stringify(state));
      } catch (e) {
        console.warn('saveState failed:', e);
      }
    }

    function loadState() {
      try {
        const raw = localStorage.getItem(LS_KEY);
        if (!raw) return false;
        const state = JSON.parse(raw);

        // Restore form fields
        if (state.niche) document.getElementById('niche').value = state.niche;
        if (state.geo) document.getElementById('geo').value = state.geo;
        if (state.apiKey) document.getElementById('apiKey').value = state.apiKey;
        if (state.geoRequest) document.getElementById('geoRequest').value = state.geoRequest;
        if (state.queryLang) document.getElementById('queryLang').value = state.queryLang;
        if (state.siteLang) document.getElementById('siteLang').value = state.siteLang;
        if (state.userCompanyData) document.getElementById('user-company-data').value = state.userCompanyData;

        // Restore data variables
        if (state.conversations) Object.assign(conversations, state.conversations);
        if (state.compilerRawXml) compilerRawXml = state.compilerRawXml;
        if (state.canvasRawHtml) canvasRawHtml = state.canvasRawHtml;
        if (state.extractedCompanies) extractedCompanies = state.extractedCompanies;
        if (state.extractedRatings) extractedRatings = state.extractedRatings;
        if (state.downloadedSites) downloadedSites = state.downloadedSites;
        if (state.downloadedRatings) downloadedRatings = state.downloadedRatings;

        // Restore section content
        if (state.sections) {
          if (state.sections.results) document.getElementById('results').innerHTML = state.sections.results;
          if (state.sections.grokMessages) document.getElementById('grok-messages').innerHTML = state.sections.grokMessages;
          if (state.sections.audienceMessages) document.getElementById('audience-messages').innerHTML = state.sections.audienceMessages;
          if (state.sections.compilerMessages) document.getElementById('compiler-messages').innerHTML = state.sections.compilerMessages;
        }

        // Restore section visibility
        if (state.visibility) {
          if (state.visibility.grok) document.getElementById('grok-section').style.display = 'block';
          if (state.visibility.audience) document.getElementById('audience-section').style.display = 'block';
          if (state.visibility.compiler) document.getElementById('compiler-section').style.display = 'block';
          if (state.visibility.canvas) {
            document.getElementById('canvas-section').style.display = 'block';
            document.getElementById('canvas-toolbar').style.display = 'flex';
            document.getElementById('editor-toolbar').style.display = 'flex';
            document.getElementById('canvas-preview').style.display = 'block';
            const iframe = document.getElementById('canvas-iframe');
            iframe.srcdoc = canvasRawHtml;
            document.getElementById('canvas-code-content').textContent = canvasRawHtml;
          }
          if (state.visibility.ratings) {
            document.getElementById('ratings-section').style.display = 'block';
            if (typeof renderRatingsGrid === 'function') renderRatingsGrid();
          }
          if (state.visibility.sites) {
            document.getElementById('sites-section').style.display = 'block';
            if (typeof renderCompaniesGrid === 'function') renderCompaniesGrid();
            // Enable fill button if we have data
            if (canvasRawHtml && compilerRawXml) {
              document.getElementById('fill-btn').disabled = false;
            }
          }
        }

        // Restore search button state
        const btn = document.getElementById('search-btn');
        if (btn) btn.disabled = false;

        // Show notification
        const ago = Math.round((Date.now() - state.ts) / 60000);
        const agoText = ago < 1 ? 'только что' : ago < 60 ? `${ago} мин. назад` : `${Math.round(ago/60)} ч. назад`;
        showNotification(`Восстановлено из кеша (${agoText})`);

        return true;
      } catch (e) {
        console.warn('loadState failed:', e);
        return false;
      }
    }

    function clearSavedState() {
      localStorage.removeItem(LS_KEY);
      showNotification('Кеш очищен');
    }

    // Strip HTML to plain text for AI processing
    function extractText(html) {
      const doc = new DOMParser().parseFromString(html, 'text/html');
      doc.querySelectorAll('script, style, svg, noscript, link, meta, header, footer, nav, iframe').forEach(el => el.remove());
      let text = doc.body?.innerText || '';
      return text.replace(/\n{3,}/g, '\n\n').replace(/[ \t]+/g, ' ').trim();
    }

    // Render company buttons grid with download status
    function renderCompaniesGrid() {
      const grid = document.getElementById('companies-grid');
      if (!grid) return;

      const doneCount = extractedCompanies.filter(c => c.status === 'done').length;
      const totalCount = extractedCompanies.length;
      const errorCount = extractedCompanies.filter(c => c.status === 'error').length;

      document.getElementById('download-progress').textContent =
        `Загружено: ${doneCount} из ${totalCount}` + (errorCount > 0 ? ` (ошибок: ${errorCount})` : '');

      grid.innerHTML = extractedCompanies.map((company, idx) => {
        const tooltip = company.status === 'error'
          ? `Ошибка: ${company.errorReason || 'неизвестна'}\nURL: ${company.url || '—'}`
          : (company.url || 'URL не найден');
        return `
        <button class="company-btn status-${company.status}"
                onclick="previewCompanySite(${idx})"
                title="${tooltip}">
          <span class="company-status-icon ${company.status}"></span>
          <span style="flex:1; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${company.name}</span>
          ${company.status === 'loading' ? '<span class="spinner-small"></span>' : ''}
        </button>`;
      }).join('');

      const fillBtn = document.getElementById('fill-btn');
      if (fillBtn) fillBtn.disabled = doneCount === 0;
    }

    // Preview a downloaded company site in iframe (or show error details)
    function previewCompanySite(idx) {
      const company = extractedCompanies[idx];
      if (!company) return;

      if (company.status === 'error') {
        alert(`Ошибка загрузки: ${company.name}\nURL: ${company.url || '—'}\nПричина: ${company.errorReason || 'неизвестна'}`);
        return;
      }
      if (company.status !== 'done') return;

      const wrap = document.getElementById('company-preview-wrap');
      const iframe = document.getElementById('company-preview-iframe');
      const title = document.getElementById('company-preview-title');

      title.textContent = `${company.name} — ${company.url}`;
      iframe.srcdoc = downloadedSites[company.name]?.html || '<p>Нет данных</p>';
      wrap.style.display = 'block';
      wrap.scrollIntoView({ behavior: 'smooth' });
    }

    // Render ratings grid (analogous to companies grid)
    function renderRatingsGrid() {
      const grid = document.getElementById('ratings-grid');
      if (!grid) return;

      const doneCount = extractedRatings.filter(c => c.status === 'done').length;
      const totalCount = extractedRatings.length;
      const errorCount = extractedRatings.filter(c => c.status === 'error').length;

      document.getElementById('ratings-progress').textContent =
        `Загружено рейтингов: ${doneCount} из ${totalCount}` + (errorCount > 0 ? ` (ошибок: ${errorCount})` : '');

      grid.innerHTML = extractedRatings.map((rating, idx) => {
        const tooltip = rating.status === 'error'
          ? `Ошибка: ${rating.errorReason || 'неизвестна'}\nURL: ${rating.url || '—'}`
          : (rating.url || 'URL не найден');
        return `
        <button class="company-btn status-${rating.status}"
                onclick="previewRatingSite(${idx})"
                title="${tooltip}">
          <span class="company-status-icon ${rating.status}"></span>
          <span style="flex:1; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${rating.name}</span>
          ${rating.status === 'loading' ? '<span class="spinner-small"></span>' : ''}
        </button>`;
      }).join('');
    }

    // Preview a downloaded rating site in iframe (or show error details)
    function previewRatingSite(idx) {
      const rating = extractedRatings[idx];
      if (!rating) return;

      if (rating.status === 'error') {
        alert(`Ошибка загрузки: ${rating.name}\nURL: ${rating.url || '—'}\nПричина: ${rating.errorReason || 'неизвестна'}`);
        return;
      }
      if (rating.status !== 'done') return;

      const wrap = document.getElementById('rating-preview-wrap');
      const iframe = document.getElementById('rating-preview-iframe');
      const title = document.getElementById('rating-preview-title');

      title.textContent = `${rating.name} — ${rating.url}`;
      iframe.srcdoc = downloadedRatings[rating.name]?.html || '<p>Нет данных</p>';
      wrap.style.display = 'block';
      wrap.scrollIntoView({ behavior: 'smooth' });
    }

    // CORS proxy list — tried in order, first success wins
    // Tested 2026-02-18: codetabs works reliably, allorigins/corsproxy.io are down
    function getProxies(url) {
      const encoded = encodeURIComponent(url);
      return [
        { name: 'codetabs',    url: `https://api.codetabs.com/v1/proxy?quest=${encoded}`, type: 'raw' },
        { name: 'allorigins',  url: `https://api.allorigins.win/get?url=${encoded}`, type: 'json', field: 'contents' },
        { name: 'corsproxy',   url: `https://corsproxy.io/?url=${encoded}`, type: 'raw' },
      ];
    }

    // Download a single site via CORS proxy (universal — works for companies & ratings)
    async function downloadSite(url, verbose) {
      const proxies = getProxies(url);
      const errors = [];

      for (const proxy of proxies) {
        try {
          const controller = new AbortController();
          const timeout = setTimeout(() => controller.abort(), 15000);
          const start = Date.now();

          const resp = await fetch(proxy.url, { signal: controller.signal });
          clearTimeout(timeout);
          const elapsed = Date.now() - start;

          if (!resp.ok) {
            errors.push({ proxy: proxy.name, error: `HTTP ${resp.status}`, ms: elapsed });
            continue;
          }

          let html;
          if (proxy.type === 'json') {
            const data = await resp.json();
            html = data[proxy.field];
          } else {
            html = await resp.text();
          }

          if (!html || html.length < 100) {
            errors.push({ proxy: proxy.name, error: `пустой/короткий ответ (${(html||'').length} байт)`, ms: elapsed });
            continue;
          }

          const text = extractText(html).substring(0, 8000);
          if (verbose) return { ok: true, html, text, proxy: proxy.name, size: html.length, ms: elapsed, errors };
          return { ok: true, html, text };
        } catch (e) {
          const reason = e.name === 'AbortError' ? 'таймаут 15с' : e.message;
          errors.push({ proxy: proxy.name, error: reason, ms: null });
          continue;
        }
      }

      const errorStr = errors.map(e => `${e.proxy}: ${e.error}${e.ms ? ` (${e.ms}мс)` : ''}`).join(' → ');
      return { ok: false, error: errorStr || 'Все прокси недоступны', errors };
    }

    // Test download from the form
    async function testDownload() {
      const url = document.getElementById('testUrl').value.trim();
      const resultEl = document.getElementById('testResult');
      if (!url) { resultEl.textContent = 'Введите URL'; return; }

      resultEl.textContent = 'Загрузка...';
      resultEl.style.color = '#d29922';

      const result = await downloadSite(url, true);

      if (result.ok) {
        resultEl.style.color = '#238636';
        resultEl.textContent = `✅ Успех через ${result.proxy} (${result.ms}мс)\nРазмер HTML: ${(result.size / 1024).toFixed(1)} KB | Текст: ${result.text.length} символов`;
        if (result.errors.length > 0) {
          resultEl.textContent += `\n⚠️ Другие прокси:\n${result.errors.map(e => `  ✗ ${e.proxy}: ${e.error}${e.ms ? ` (${e.ms}мс)` : ''}`).join('\n')}`;
        }
      } else {
        resultEl.style.color = '#f85149';
        resultEl.textContent = `❌ Все прокси не сработали:\n${result.errors.map(e => `  ✗ ${e.proxy}: ${e.error}${e.ms ? ` (${e.ms}мс)` : ''}`).join('\n')}`;
      }
    }

    // Download a single company site
    async function downloadCompanySite(company, index) {
      if (!company.url) {
        extractedCompanies[index].status = 'error';
        extractedCompanies[index].errorReason = 'URL не найден';
        renderCompaniesGrid();
        return;
      }

      extractedCompanies[index].status = 'loading';
      renderCompaniesGrid();

      const result = await downloadSite(company.url);
      if (result.ok) {
        downloadedSites[company.name] = { html: result.html, text: result.text };
        extractedCompanies[index].status = 'done';
      } else {
        extractedCompanies[index].status = 'error';
        extractedCompanies[index].errorReason = result.error;
      }
      renderCompaniesGrid();
    }

    // Download a single rating site
    async function downloadRatingSite(rating, index) {
      if (!rating.url) {
        extractedRatings[index].status = 'error';
        extractedRatings[index].errorReason = 'URL не найден';
        renderRatingsGrid();
        return;
      }

      extractedRatings[index].status = 'loading';
      renderRatingsGrid();

      const result = await downloadSite(rating.url);
      if (result.ok) {
        downloadedRatings[rating.name] = { html: result.html, text: result.text };
        extractedRatings[index].status = 'done';
      } else {
        extractedRatings[index].status = 'error';
        extractedRatings[index].errorReason = result.error;
      }
      renderRatingsGrid();
    }

    // Step 7b: Fill template with real data from downloaded sites + user data
    async function fillTemplate() {
      const apiKey = document.getElementById("apiKey").value.trim();
      const userCompanyData = document.getElementById("user-company-data").value.trim();
      const niche = document.getElementById("niche").value.trim();
      const fillBtn = document.getElementById("fill-btn");
      const fillLoading = document.getElementById("fill-loading");

      if (!apiKey) return alert("Введите API-ключ OpenRouter");
      if (!canvasRawHtml) return alert("Сначала сгенерируйте сайт (шаги 1-6)");

      fillBtn.disabled = true;
      fillLoading.style.display = "flex";

      // Build ratings data blocks (priority source — structured reviews)
      const MAX_RATINGS_CHARS = 60000;
      let ratingsChars = 0;
      const ratingDataBlocks = extractedRatings
        .filter(r => r.status === 'done' && downloadedRatings[r.name])
        .map(r => {
          const text = downloadedRatings[r.name].text.substring(0, 8000);
          ratingsChars += text.length;
          if (ratingsChars > MAX_RATINGS_CHARS) return null;
          return `=== ${r.name} (${r.url}) ===\n${text}`;
        })
        .filter(Boolean)
        .join("\n\n---\n\n");

      // Build company data blocks — only TOP-5 companies have downloaded sites
      const MAX_COMPANY_CHARS = 40000;
      let companyChars = 0;
      const companyDataBlocks = extractedCompanies
        .filter(c => c.status === 'done' && downloadedSites[c.name])
        .map(c => {
          const text = downloadedSites[c.name].text.substring(0, 5000);
          companyChars += text.length;
          if (companyChars > MAX_COMPANY_CHARS) return null;
          return `=== ${c.name} (${c.url}) ===\n${text}`;
        })
        .filter(Boolean)
        .join("\n\n---\n\n");

      const fillSiteLang = document.getElementById("siteLang").value;
      const fillSiteLangStr = `Весь контент сайта на языке: ${fillSiteLang}`;

      // --- Защита PROTECTED блоков ---
      let savedSeoBlock = '';
      let savedCountersBlock = '';
      let cleanedCanvasHtml = canvasRawHtml;

      const seoMatch = cleanedCanvasHtml.match(/<!-- PROTECTED:SEO:START -->([\s\S]*?)<!-- PROTECTED:SEO:END -->/);
      if (seoMatch) {
        savedSeoBlock = seoMatch[1];
        cleanedCanvasHtml = cleanedCanvasHtml.replace(seoMatch[0], '<!-- PROTECTED:SEO:START --><!-- PROTECTED:SEO:END -->');
      }
      const countersMatch = cleanedCanvasHtml.match(/<!-- PROTECTED:COUNTERS:START -->([\s\S]*?)<!-- PROTECTED:COUNTERS:END -->/);
      if (countersMatch) {
        savedCountersBlock = countersMatch[1];
        cleanedCanvasHtml = cleanedCanvasHtml.replace(countersMatch[0], '<!-- PROTECTED:COUNTERS:START --><!-- PROTECTED:COUNTERS:END -->');
      }

      const fillPrompt = `ЯЗЫК САЙТА: ${fillSiteLangStr}

РОЛЬ: Ты — Senior SEO-копирайтер и веб-разработчик. Твоя задача — наполнить готовый HTML-шаблон рейтинга реальными данными компаний.

ВХОДНЫЕ ДАННЫЕ:

1. HTML-ШАБЛОН САЙТА:
<template>
${cleanedCanvasHtml}
</template>

2. ДАННЫЕ С РЕЙТИНГОВЫХ САЙТОВ (структурированные обзоры — ОСНОВНОЙ источник фактов):
<ratings_data>
${ratingDataBlocks || "(Рейтинговые сайты не были скачаны)"}
</ratings_data>

3. ДАННЫЕ С САЙТОВ КОМПАНИЙ (только TOP-5, дополнительный источник):
<companies_data>
${companyDataBlocks || "(Сайты компаний не были скачаны)"}
</companies_data>

4. ДАННЫЕ КОМПАНИИ ПОЛЬЗОВАТЕЛЯ (ДОЛЖНА СТАТЬ #1 В РЕЙТИНГЕ):
<user_company>
${userCompanyData || "(Пользователь не предоставил данные своей компании)"}
</user_company>

5. XML-СТРУКТУРА КРИТЕРИЕВ:
<criteria>
${compilerRawXml}
</criteria>

ИСТОЧНИКИ ДАННЫХ И ПРИОРИТЕТ:
1. РЕЙТИНГОВЫЕ САЙТЫ (приоритет) — данные для ВСЕХ компаний, включая TOP-5 и компактную таблицу 6+.
2. САЙТЫ КОМПАНИЙ (TOP-5 только) — детальные данные для расширенных карточек первых 5 компаний.
3. Для компаний 6+ используй ТОЛЬКО данные из рейтинговых сайтов. Сайты этих компаний НЕ скачаны.

ЗАДАЧА:
1. Используй данные рейтинговых сайтов (ratings_data) как ОСНОВНОЙ источник фактов: названия компаний, описания, цены, баллы, преимущества, недостатки.
2. Дополняй данными с сайтов компаний (companies_data) — для TOP-5 карточек.
3. Наполни HTML-шаблон реальными данными:
   - Замени placeholder-названия на реальные.
   - Замени placeholder-описания на реальные данные.
   - Заполни метрики на основе анализа данных.
   - Обнови баллы и рейтинги.
4. КРИТИЧЕСКИ ВАЖНО: Компания пользователя (из user_company) ДОЛЖНА быть на 1 месте с бейджем "Выбор редакции" и наивысшими баллами.
5. Сохрани всю структуру, стили, Schema.org разметку и JavaScript из шаблона.
6. ${fillSiteLangStr}.

СОХРАНЕНИЕ РАЗМЕТКИ БЛОКОВ:
Все атрибуты data-block-id, data-block-type, data-company-rank на элементах <section> и <tr> должны быть сохранены в неизменном виде. Не удалять, не менять нумерацию. Если добавляешь новые блоки — продолжай нумерацию data-block-id с максимального существующего +1.

ЗАЩИТНЫЕ МАРКЕРЫ:
Блоки между <!-- PROTECTED:SEO:START/END --> и <!-- PROTECTED:COUNTERS:START/END --> в <head> НЕ ТРОГАЙ. Не удаляй маркеры, не меняй содержимое между ними, не перемещай их.

SCHEMA.ORG: Не дублируй JSON-LD сущности. Question — только внутри FAQPage.mainEntity, не создавай отдельные JSON-LD блоки для Question. Person — один блок с @id, остальные ссылаются через @id.

ФОРМАТ: Выведи ТОЛЬКО полный HTML-код. Без пояснений, без markdown, без тройных бэктиков. Чистый HTML начиная с <!DOCTYPE html>.`;

      try {
        const fillData = await callModel("anthropic/claude-sonnet-4.5", [{ role: "user", content: fillPrompt }], apiKey);

        if (fillData.error) {
          fillLoading.innerHTML = `<div class="error-text" style="padding:20px;">[Ошибка] ${fillData.error}</div>`;
        } else {
          let filledHtml = fillData.content;
          filledHtml = filledHtml.replace(/^```html?\s*\n?/i, '').replace(/\n?```\s*$/i, '').trim();

          // --- Восстановление PROTECTED блоков ---
          if (savedSeoBlock) {
            if (filledHtml.includes('<!-- PROTECTED:SEO:START -->')) {
              filledHtml = filledHtml.replace(
                /<!-- PROTECTED:SEO:START -->[\s\S]*?<!-- PROTECTED:SEO:END -->/,
                `<!-- PROTECTED:SEO:START -->${savedSeoBlock}<!-- PROTECTED:SEO:END -->`
              );
            } else {
              filledHtml = filledHtml.replace('</head>', `<!-- PROTECTED:SEO:START -->${savedSeoBlock}<!-- PROTECTED:SEO:END -->\n</head>`);
            }
          }
          if (savedCountersBlock) {
            if (filledHtml.includes('<!-- PROTECTED:COUNTERS:START -->')) {
              filledHtml = filledHtml.replace(
                /<!-- PROTECTED:COUNTERS:START -->[\s\S]*?<!-- PROTECTED:COUNTERS:END -->/,
                `<!-- PROTECTED:COUNTERS:START -->${savedCountersBlock}<!-- PROTECTED:COUNTERS:END -->`
              );
            } else {
              filledHtml = filledHtml.replace('</head>', `<!-- PROTECTED:COUNTERS:START -->${savedCountersBlock}<!-- PROTECTED:COUNTERS:END -->\n</head>`);
            }
          }

          canvasRawHtml = filledHtml;

          const iframe = document.getElementById("canvas-iframe");
          iframe.srcdoc = filledHtml;

          const codeContent = document.getElementById("canvas-code-content");
          codeContent.textContent = filledHtml;

          fillLoading.style.display = "none";

          // Show editor toolbar + reset editor state
          document.getElementById("editor-toolbar").style.display = "flex";
          editorActive = false;
          document.getElementById('editor-mode-toggle').checked = false;
          historyStack = [];
          historyIndex = -1;
          updateUndoRedoButtons();

          document.getElementById("canvas-section").scrollIntoView({ behavior: "smooth" });
          saveState(); // Save after fill template
          updateProjectStatus('filled', canvasRawHtml);
        }
      } catch (err) {
        fillLoading.innerHTML = `<div class="error-text" style="padding:20px;">[Ошибка] ${err.message}</div>`;
      }

      fillBtn.disabled = false;
    }

    function switchCanvasTab(tab) {
      const previewEl = document.getElementById('canvas-preview');
      const codeEl = document.getElementById('canvas-code-view');
      const tabs = document.querySelectorAll('.canvas-tab');
      tabs.forEach(t => t.classList.remove('active'));
      if (tab === 'preview') {
        previewEl.style.display = 'block';
        codeEl.style.display = 'none';
        tabs[0].classList.add('active');
      } else {
        previewEl.style.display = 'none';
        codeEl.style.display = 'block';
        tabs[1].classList.add('active');
      }
    }

    // =============================================
    // Block Editor — state
    // =============================================
    let editorActive = false;
    let historyStack = [];
    let historyIndex = -1;
    const MAX_HISTORY = 20;
    let editorInjected = false;

    // =============================================
    // 3C — SEO Panel toggle & apply
    // =============================================
    function toggleSeoPanel() {
      const panel = document.getElementById('seo-panel');
      panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
    }

    function showNotification(text, isError) {
      const div = document.createElement('div');
      div.className = 'seo-notification';
      if (isError) div.style.background = '#da3633';
      div.textContent = text;
      document.body.appendChild(div);
      setTimeout(() => div.remove(), 2600);
    }

    function applySeoCounters() {
      const iframe = document.getElementById('canvas-iframe');
      const iDoc = iframe.contentDocument;
      if (!iDoc) return showNotification('Сначала сгенерируйте сайт', true);

      const metaTitle = document.getElementById('metaTitle').value.trim();
      const metaDesc = document.getElementById('metaDesc').value.trim();
      const metaKeywords = document.getElementById('metaKeywords').value.trim();
      const metaYandex = document.getElementById('metaYandex').value.trim();
      const metaGoogle = document.getElementById('metaGoogle').value.trim();
      const metaOgImage = document.getElementById('metaOgImage').value.trim();
      const counterYandex = document.getElementById('counterYandex').value.trim();
      const counterGoogle = document.getElementById('counterGoogle').value.trim();

      const head = iDoc.head;

      // --- SEO block ---
      let seoContent = '';
      if (metaTitle) seoContent += `<title>${metaTitle}</title>\n`;
      if (metaDesc) seoContent += `<meta name="description" content="${metaDesc}">\n`;
      if (metaKeywords) seoContent += `<meta name="keywords" content="${metaKeywords}">\n`;
      if (metaYandex) seoContent += `<meta name="yandex-verification" content="${metaYandex}">\n`;
      if (metaGoogle) seoContent += `<meta name="google-site-verification" content="${metaGoogle}">\n`;
      if (metaTitle) seoContent += `<meta property="og:title" content="${metaTitle}">\n`;
      if (metaDesc) seoContent += `<meta property="og:description" content="${metaDesc}">\n`;
      if (metaOgImage) seoContent += `<meta property="og:image" content="${metaOgImage}">\n`;
      seoContent += `<meta property="og:type" content="website">\n`;

      // --- Counters block ---
      let countersContent = '';
      if (counterYandex) countersContent += counterYandex + '\n';
      if (counterGoogle) countersContent += counterGoogle + '\n';

      // Update head innerHTML via string manipulation for reliability
      let headHtml = head.innerHTML;

      // Replace or insert SEO block
      const seoRe = /<!-- PROTECTED:SEO:START -->[\s\S]*?<!-- PROTECTED:SEO:END -->/;
      const seoBlock = `<!-- PROTECTED:SEO:START -->\n${seoContent}<!-- PROTECTED:SEO:END -->`;
      if (seoRe.test(headHtml)) {
        headHtml = headHtml.replace(seoRe, seoBlock);
      } else {
        headHtml += '\n' + seoBlock;
      }

      // Replace or insert Counters block
      const cntRe = /<!-- PROTECTED:COUNTERS:START -->[\s\S]*?<!-- PROTECTED:COUNTERS:END -->/;
      const cntBlock = `<!-- PROTECTED:COUNTERS:START -->\n${countersContent}<!-- PROTECTED:COUNTERS:END -->`;
      if (cntRe.test(headHtml)) {
        headHtml = headHtml.replace(cntRe, cntBlock);
      } else {
        headHtml += '\n' + cntBlock;
      }

      head.innerHTML = headHtml;
      syncCanvasRawHtml();
      showNotification('Счётчики и мета-теги применены');
    }

    // =============================================
    // 3B.6 — Autosave canvasRawHtml from iframe
    // =============================================
    function getActiveEditorDoc() {
      // If editor window is open, prefer it
      if (editorWindow && !editorWindow.closed && editorWindow.document?.body) {
        return editorWindow.document;
      }
      const iframe = document.getElementById('canvas-iframe');
      return iframe?.contentDocument || null;
    }

    function syncCanvasRawHtml() {
      if (editorWindow && !editorWindow.closed) {
        // Sync from editor window — get clean HTML without editor artifacts
        const doc = editorWindow.document;
        if (doc?.documentElement) {
          let html = '<!DOCTYPE html>' + doc.documentElement.outerHTML;
          // Clean editor artifacts
          html = html.replace(/<div id="__ew_toolbar__">[\s\S]*?<\/div>\s*/, '');
          html = html.replace(/<style id="__editor_style__">[\s\S]*?<\/style>/g, '');
          html = html.replace(/<style id="__editor_spin_style__">[\s\S]*?<\/style>/g, '');
          html = html.replace(/<style id="__ew_anim_style__">[\s\S]*?<\/style>/g, '');
          html = html.replace(/<div class="__editor_toolbar__">[\s\S]*?<\/div>/g, '');
          html = html.replace(/<div class="__editor_comment_popup__">[\s\S]*?<\/div>/g, '');
          html = html.replace(/<div class="__editor_loader__">[\s\S]*?<\/div>/g, '');
          html = html.replace(/<div id="__ew_seo_panel__">[\s\S]*?<\/div>\s*<\/div>/g, '');
          html = html.replace(/<div id="__ew_notification__">[\s\S]*?<\/div>/g, '');
          html = html.replace(/ ?class="__editor_hover__"/g, '');
          html = html.replace(/ ?class="__editor_collapsed__"/g, '');
          html = html.replace(/ style="position: relative;"/g, '');
          html = html.replace(/ style="padding-top: 50px;"/g, '');
          canvasRawHtml = html;
          editorWindowDirty = true;
        }
      } else {
        const iframe = document.getElementById('canvas-iframe');
        if (iframe?.contentDocument?.documentElement) {
          canvasRawHtml = '<!DOCTYPE html>' + iframe.contentDocument.documentElement.outerHTML;
        }
      }
      // Also update code view
      const codeContent = document.getElementById("canvas-code-content");
      if (codeContent) codeContent.textContent = canvasRawHtml;
      saveState(); // Autosave after any editor action
      updateProjectHtml(canvasRawHtml);
    }

    // =============================================
    // 3B.5 — Undo / Redo
    // =============================================
    function pushSnapshot() {
      const doc = getActiveEditorDoc();
      const body = doc?.body;
      if (!body) return;

      // If we're in the middle of history, discard the forward part
      if (historyIndex < historyStack.length - 1) {
        historyStack = historyStack.slice(0, historyIndex + 1);
      }

      historyStack.push(body.innerHTML);

      if (historyStack.length > MAX_HISTORY) {
        historyStack.shift();
      }
      historyIndex = historyStack.length - 1;
      updateUndoRedoButtons();
    }

    function editorUndo() {
      if (historyIndex <= 0) return;
      historyIndex--;
      restoreSnapshot();
    }

    function editorRedo() {
      if (historyIndex >= historyStack.length - 1) return;
      historyIndex++;
      restoreSnapshot();
    }

    function restoreSnapshot() {
      const doc = getActiveEditorDoc();
      const body = doc?.body;
      if (!body || historyIndex < 0 || historyIndex >= historyStack.length) return;

      body.innerHTML = historyStack[historyIndex];
      // Restore padding-top if in editor window
      if (editorWindow && !editorWindow.closed && doc === editorWindow.document) {
        body.style.paddingTop = '50px';
      }
      syncCanvasRawHtml();
      updateUndoRedoButtons();
      // Re-inject editor event listeners after restoring
      if (editorActive) injectEditorListeners(doc);
    }

    function updateUndoRedoButtons() {
      document.getElementById('undo-btn').disabled = historyIndex <= 0;
      document.getElementById('redo-btn').disabled = historyIndex >= historyStack.length - 1;
    }

    // =============================================
    // 3B.1 — Editor mode toggle
    // =============================================
    function toggleEditorMode(on) {
      editorActive = on;
      const undoBtn = document.getElementById('undo-btn');
      const redoBtn = document.getElementById('redo-btn');

      undoBtn.style.display = on ? '' : 'none';
      redoBtn.style.display = on ? '' : 'none';

      const iDoc = getActiveEditorDoc();
      if (!iDoc) return;

      if (on) {
        // Take initial snapshot
        if (historyStack.length === 0) pushSnapshot();
        injectEditorListeners(iDoc);
      } else {
        removeEditorOverlays(iDoc);
      }
    }

    // =============================================
    // 3B.2 — Hover overlay + toolbar injection
    // =============================================
    function injectEditorListeners(iDoc) {
      // Remove previous injected style/listeners if any
      removeEditorOverlays(iDoc);

      // Inject overlay style
      const style = iDoc.createElement('style');
      style.id = '__editor_style__';
      style.textContent = `
        [data-block-id].__editor_hover__ {
          outline: 2px dashed #3b82f6 !important;
          outline-offset: 4px !important;
          position: relative;
        }
        .__editor_toolbar__ {
          position: absolute;
          top: 4px;
          right: 4px;
          z-index: 9999;
          display: flex;
          gap: 4px;
          background: #fff;
          border-radius: 8px;
          box-shadow: 0 2px 12px rgba(0,0,0,0.18);
          padding: 4px 6px;
          font-size: 13px;
        }
        .__editor_toolbar__ button {
          background: #f3f4f6;
          border: 1px solid #d1d5db;
          border-radius: 6px;
          padding: 4px 8px;
          cursor: pointer;
          font-size: 13px;
          line-height: 1;
        }
        .__editor_toolbar__ button:hover {
          background: #e5e7eb;
        }
        .__editor_comment_popup__ {
          position: absolute;
          top: 40px;
          right: 4px;
          z-index: 10000;
          background: #fff;
          border: 1px solid #d1d5db;
          border-radius: 8px;
          box-shadow: 0 4px 16px rgba(0,0,0,0.2);
          padding: 12px;
          width: 300px;
        }
        .__editor_comment_popup__ textarea {
          width: 100%;
          min-height: 80px;
          border: 1px solid #d1d5db;
          border-radius: 6px;
          padding: 8px;
          font-size: 13px;
          resize: vertical;
          margin-bottom: 8px;
        }
        .__editor_comment_popup__ button {
          background: #3b82f6;
          color: #fff;
          border: none;
          border-radius: 6px;
          padding: 6px 16px;
          cursor: pointer;
          font-size: 13px;
        }
        .__editor_loader__ {
          position: absolute;
          inset: 0;
          background: rgba(255,255,255,0.85);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 9998;
          font-size: 14px;
          color: #333;
          border-radius: inherit;
        }
        .__editor_collapsed__ > *:not(.__editor_toolbar__) {
          display: none !important;
        }
      `;
      iDoc.head.appendChild(style);

      let hoverTimeout = null;
      let currentToolbar = null;

      const onMouseOver = (e) => {
        const block = e.target.closest('[data-block-id]');
        if (!block) return;

        clearTimeout(hoverTimeout);
        block.classList.add('__editor_hover__');

        if (currentToolbar && currentToolbar.parentElement !== block) {
          currentToolbar.remove();
          currentToolbar = null;
        }
        if (!currentToolbar) {
          currentToolbar = createBlockToolbar(block, iDoc);
          // Ensure the block has position:relative for absolute toolbar
          if (getComputedStyle(block).position === 'static') {
            block.style.position = 'relative';
          }
          block.appendChild(currentToolbar);
        }
      };

      const onMouseOut = (e) => {
        const block = e.target.closest('[data-block-id]');
        if (!block) return;

        hoverTimeout = setTimeout(() => {
          // Check if mouse is still over this block or its toolbar
          const hovered = iDoc.querySelectorAll(':hover');
          for (const el of hovered) {
            if (el === block || block.contains(el)) return;
          }
          block.classList.remove('__editor_hover__');
          if (currentToolbar && currentToolbar.parentElement === block) {
            currentToolbar.remove();
            currentToolbar = null;
          }
        }, 200);
      };

      iDoc.body.addEventListener('mouseover', onMouseOver);
      iDoc.body.addEventListener('mouseout', onMouseOut);

      // Store references for cleanup
      iDoc.body.__editorMouseOver = onMouseOver;
      iDoc.body.__editorMouseOut = onMouseOut;
    }

    function createBlockToolbar(block, iDoc) {
      const toolbar = iDoc.createElement('div');
      toolbar.className = '__editor_toolbar__';

      const blockType = block.getAttribute('data-block-type');
      const isCollapsed = block.classList.contains('__editor_collapsed__');

      // Delete button
      const delBtn = iDoc.createElement('button');
      delBtn.textContent = '🗑';
      delBtn.title = 'Удалить блок';
      delBtn.onclick = (e) => {
        e.stopPropagation();
        pushSnapshot();
        if (blockType === 'company-card' || blockType === 'company-row') {
          block.remove();
          recalcCompanyRanks(iDoc);
        } else {
          block.remove();
        }
        syncCanvasRawHtml();
        if (editorActive) injectEditorListeners(iDoc);
      };
      toolbar.appendChild(delBtn);

      // Comment button
      const commentBtn = iDoc.createElement('button');
      commentBtn.textContent = '💬';
      commentBtn.title = 'Комментарий к блоку';
      commentBtn.onclick = (e) => {
        e.stopPropagation();
        openCommentPopup(block, iDoc);
      };
      toolbar.appendChild(commentBtn);

      // Collapse/expand button
      const collapseBtn = iDoc.createElement('button');
      collapseBtn.textContent = isCollapsed ? '↕ ▸' : '↕ ▾';
      collapseBtn.title = isCollapsed ? 'Развернуть' : 'Свернуть';
      collapseBtn.onclick = (e) => {
        e.stopPropagation();
        block.classList.toggle('__editor_collapsed__');
        collapseBtn.textContent = block.classList.contains('__editor_collapsed__') ? '↕ ▸' : '↕ ▾';
        collapseBtn.title = block.classList.contains('__editor_collapsed__') ? 'Развернуть' : 'Свернуть';
      };
      toolbar.appendChild(collapseBtn);

      return toolbar;
    }

    // =============================================
    // 3B.3 — Delete company with rank recalc
    // =============================================
    function recalcCompanyRanks(iDoc) {
      const allRanked = Array.from(iDoc.querySelectorAll('[data-company-rank]'));
      // Sort by DOM order (already in order from querySelectorAll)
      allRanked.forEach((el, idx) => {
        const oldRank = el.getAttribute('data-company-rank');
        const newRank = String(idx + 1);
        el.setAttribute('data-company-rank', newRank);

        // Update visual rank number inside the element
        // Look for first element that contains just the old rank number
        const walker = iDoc.createTreeWalker(el, NodeFilter.SHOW_TEXT);
        while (walker.nextNode()) {
          const node = walker.currentNode;
          const trimmed = node.textContent.trim();
          if (trimmed === oldRank || trimmed === '#' + oldRank || trimmed === oldRank + '.') {
            node.textContent = node.textContent.replace(oldRank, newRank);
            break;
          }
        }
      });

      // Update Schema.org JSON-LD ItemList
      const scripts = iDoc.querySelectorAll('script[type="application/ld+json"]');
      scripts.forEach(script => {
        try {
          const json = JSON.parse(script.textContent);
          if (json['@type'] === 'ItemList' && Array.isArray(json.itemListElement)) {
            // Remove items whose name/position no longer exists
            // Re-index positions
            json.itemListElement.forEach((item, idx) => {
              item.position = idx + 1;
            });
            // If items were deleted, we need to reconcile — but we can only re-index
            // The delete already removed the DOM element; ItemList entries won't auto-sync
            // So we just re-number what's left
            script.textContent = JSON.stringify(json, null, 2);
          }
        } catch (e) { /* ignore parse errors */ }
      });
    }

    // =============================================
    // 3B.4 — Block regeneration via comment
    // =============================================
    function openCommentPopup(block, iDoc) {
      // Remove existing popups
      iDoc.querySelectorAll('.__editor_comment_popup__').forEach(p => p.remove());

      const popup = iDoc.createElement('div');
      popup.className = '__editor_comment_popup__';

      const textarea = iDoc.createElement('textarea');
      textarea.placeholder = 'Опишите, что изменить в этом блоке...';
      popup.appendChild(textarea);

      const sendBtn = iDoc.createElement('button');
      sendBtn.textContent = 'Отправить';
      sendBtn.onclick = async () => {
        const userComment = textarea.value.trim();
        if (!userComment) return;
        popup.remove();
        await regenerateBlock(block, userComment, iDoc);
      };
      popup.appendChild(sendBtn);

      if (getComputedStyle(block).position === 'static') {
        block.style.position = 'relative';
      }
      block.appendChild(popup);
      textarea.focus();
    }

    async function regenerateBlock(block, userComment, iDoc) {
      const apiKey = document.getElementById("apiKey").value.trim();
      if (!apiKey) return showNotification('Введите API-ключ OpenRouter', true);

      // Save snapshot for undo
      pushSnapshot();

      // Show loader on block
      const loader = iDoc.createElement('div');
      loader.className = '__editor_loader__';
      loader.innerHTML = '<div style="text-align:center;"><div style="border:3px solid #e5e7eb;border-top-color:#3b82f6;border-radius:50%;width:28px;height:28px;animation:spin 0.8s linear infinite;margin:0 auto 8px;"></div>Регенерация...</div>';
      // Add spin keyframes if not present
      if (!iDoc.getElementById('__editor_spin_style__')) {
        const spinStyle = iDoc.createElement('style');
        spinStyle.id = '__editor_spin_style__';
        spinStyle.textContent = '@keyframes spin { to { transform: rotate(360deg); } }';
        iDoc.head.appendChild(spinStyle);
      }
      if (getComputedStyle(block).position === 'static') {
        block.style.position = 'relative';
      }
      block.appendChild(loader);

      // Collect context
      const blockHtml = block.outerHTML;
      const siteStyles = Array.from(iDoc.querySelectorAll('style'))
        .map(s => s.textContent)
        .join('\n');
      const siteLang = document.getElementById('siteLang')?.value || 'Русский';

      const regenPrompt = `РОЛЬ: Ты — фронтенд-разработчик. Перерисуй HTML-блок по инструкции пользователя.

ЯЗЫК КОНТЕНТА: ${siteLang}

СТИЛЕВОЙ КОНТЕКСТ САЙТА (НЕ МЕНЯЙ СТИЛИ — используй те же CSS-классы, custom properties, шрифты и цветовую схему):
<site_styles>
${siteStyles}
</site_styles>

ТЕКУЩИЙ HTML БЛОКА:
<current_block>
${blockHtml}
</current_block>

ИНСТРУКЦИЯ ПОЛЬЗОВАТЕЛЯ:
${userComment}

ПРАВИЛА:
1. Верни ТОЛЬКО обновлённый HTML блока — один корневой элемент <section data-block-id="..." data-block-type="...">
2. Сохрани ВСЕ data-атрибуты (data-block-id, data-block-type, data-company-rank) без изменений
3. Используй ТОЛЬКО те CSS-классы, custom properties (:root переменные) и шрифты, которые определены в стилевом контексте
4. Если пользователь просит изменить визуал но сохранить текст — сохрани весь текстовый контент дословно
5. Не добавляй новые <style>, <link> или <script> теги
6. Не используй inline-стили, которые конфликтуют с существующими CSS custom properties
7. Формат ответа: только HTML, без пояснений, без markdown, без обёрток в тройные бэктики`;

      try {
        const data = await callModel("anthropic/claude-sonnet-4.5", [{ role: "user", content: regenPrompt }], apiKey);

        if (data.error) {
          loader.remove();
          showNotification('Ошибка регенерации: ' + data.error, true);
          // Undo the snapshot (rollback)
          editorUndo();
          return;
        }

        let newHtml = data.content;
        newHtml = newHtml.replace(/^```html?\s*\n?/i, '').replace(/\n?```\s*$/i, '').trim();

        block.outerHTML = newHtml;
        loader.remove();
        syncCanvasRawHtml();
        if (editorActive) injectEditorListeners(iDoc);
      } catch (err) {
        loader.remove();
        showNotification('Ошибка регенерации: ' + err.message, true);
        editorUndo();
      }
    }

    function removeEditorOverlays(iDoc) {
      if (!iDoc) return;
      // Remove injected style
      const style = iDoc.getElementById('__editor_style__');
      if (style) style.remove();
      // Remove all toolbars and popups
      iDoc.querySelectorAll('.__editor_toolbar__, .__editor_comment_popup__, .__editor_loader__').forEach(el => el.remove());
      // Remove hover classes
      iDoc.querySelectorAll('.__editor_hover__').forEach(el => el.classList.remove('__editor_hover__'));
      // Remove event listeners
      if (iDoc.body?.__editorMouseOver) {
        iDoc.body.removeEventListener('mouseover', iDoc.body.__editorMouseOver);
        iDoc.body.removeEventListener('mouseout', iDoc.body.__editorMouseOut);
        delete iDoc.body.__editorMouseOver;
        delete iDoc.body.__editorMouseOut;
      }
    }

    // =============================================
    // 3B.7 — Download HTML
    // =============================================
    function downloadHtml() {
      const iframe = document.getElementById('canvas-iframe');
      const iDoc = iframe.contentDocument;
      if (!iDoc) return showNotification('Нет сгенерированного сайта', true);

      // Clone the document to clean up editor artifacts
      let html = '<!DOCTYPE html>' + iDoc.documentElement.outerHTML;

      // Remove editor artifacts
      html = html.replace(/<style id="__editor_style__">[\s\S]*?<\/style>/g, '');
      html = html.replace(/<style id="__editor_spin_style__">[\s\S]*?<\/style>/g, '');
      html = html.replace(/<div class="__editor_toolbar__">[\s\S]*?<\/div>/g, '');
      html = html.replace(/<div class="__editor_comment_popup__">[\s\S]*?<\/div>/g, '');
      html = html.replace(/<div class="__editor_loader__">[\s\S]*?<\/div>/g, '');
      html = html.replace(/ ?class="__editor_hover__"/g, '');
      html = html.replace(/ ?class="__editor_collapsed__"/g, '');
      // Clean outline inline styles added by editor
      html = html.replace(/ style="position: relative;"/g, '');

      const niche = document.getElementById('niche')?.value?.trim() || 'site';
      const dateStr = new Date().toISOString().slice(0, 10);
      const filename = `rating-${niche.replace(/[^a-zA-Zа-яА-Я0-9]/g, '_')}-${dateStr}.html`;

      const blob = new Blob([html], { type: 'text/html; charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
    }

    // =============================================
    // Keyboard shortcuts for undo/redo (main window iframe)
    // =============================================
    document.addEventListener('keydown', (e) => {
      if (!editorActive) return;
      if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
        e.preventDefault();
        editorUndo();
      }
      if ((e.ctrlKey || e.metaKey) && e.key === 'z' && e.shiftKey) {
        e.preventDefault();
        editorRedo();
      }
    });

    // =============================================
    // Правка #8 — Editor in separate window (window.open)
    // =============================================
    let editorWindow = null;
    let editorWindowDirty = false;

    function openInEditor() {
      if (!canvasRawHtml) return showNotification('Сначала сгенерируйте сайт', true);

      editorWindow = window.open('', '_blank');
      if (!editorWindow) return showNotification('Браузер заблокировал popup — разрешите всплывающие окна', true);

      editorWindow.document.open();
      editorWindow.document.write(canvasRawHtml);
      editorWindow.document.close();

      // Wait for document to load, then inject editor
      editorWindow.addEventListener('load', () => {
        injectEditor(editorWindow);
      });
      // Fallback if load already fired
      setTimeout(() => {
        if (editorWindow && editorWindow.document.body && !editorWindow.document.getElementById('__ew_toolbar__')) {
          injectEditor(editorWindow);
        }
      }, 500);
    }

    function injectEditor(win) {
      const doc = win.document;

      // Pass config to editor window
      win.__EDITOR_CONFIG__ = {
        apiKey: document.getElementById('apiKey').value.trim(),
        model: 'anthropic/claude-sonnet-4.5',
        siteLang: document.getElementById('siteLang')?.value || 'Русский',
        projectId: currentProjectId
      };

      // Add padding-top for toolbar
      doc.body.style.paddingTop = '50px';

      // Inject toolbar
      const toolbar = doc.createElement('div');
      toolbar.id = '__ew_toolbar__';
      toolbar.innerHTML = `
        <label style="display:flex;align-items:center;gap:6px;cursor:pointer;">
          <input type="checkbox" id="__ew_edit_toggle__"> Редактирование
        </label>
        <button id="__ew_undo__" disabled style="opacity:0.4;">↩ Отменить</button>
        <button id="__ew_redo__" disabled style="opacity:0.4;">↪ Повторить</button>
        <span style="flex:1;"></span>
        <button id="__ew_seo__">SEO</button>
        <button id="__ew_save__" style="background:#238636;border-color:#238636;color:#fff;">Сохранить</button>
        <button id="__ew_download__" style="background:#1f6feb;border-color:#1f6feb;color:#fff;">Скачать HTML</button>
      `;
      Object.assign(toolbar.style, {
        position: 'fixed', top: '0', left: '0', right: '0', zIndex: '99999',
        height: '44px', display: 'flex', alignItems: 'center', gap: '8px',
        padding: '0 16px', background: '#1c2128', borderBottom: '1px solid #30363d',
        fontFamily: '-apple-system,BlinkMacSystemFont,sans-serif', fontSize: '13px', color: '#e1e4e8'
      });
      // Style buttons
      const btnStyle = 'background:#21262d;border:1px solid #30363d;border-radius:6px;padding:5px 10px;color:#c9d1d9;cursor:pointer;font-size:12px;';
      toolbar.querySelectorAll('button').forEach(b => b.style.cssText += btnStyle);

      doc.body.insertBefore(toolbar, doc.body.firstChild);

      // Editor state for this window
      let ewEditorActive = false;
      let ewHistoryStack = [];
      let ewHistoryIndex = -1;

      function ewPushSnapshot() {
        const snap = doc.body.innerHTML;
        ewHistoryStack = ewHistoryStack.slice(0, ewHistoryIndex + 1);
        ewHistoryStack.push(snap);
        if (ewHistoryStack.length > 20) ewHistoryStack.shift();
        ewHistoryIndex = ewHistoryStack.length - 1;
        ewUpdateUndoRedo();
        editorWindowDirty = true;
      }

      function ewUndo() {
        if (ewHistoryIndex <= 0) return;
        ewHistoryIndex--;
        doc.body.innerHTML = ewHistoryStack[ewHistoryIndex];
        doc.body.style.paddingTop = '50px';
        if (ewEditorActive) ewInjectListeners();
        ewUpdateUndoRedo();
        ewSyncBack();
      }

      function ewRedo() {
        if (ewHistoryIndex >= ewHistoryStack.length - 1) return;
        ewHistoryIndex++;
        doc.body.innerHTML = ewHistoryStack[ewHistoryIndex];
        doc.body.style.paddingTop = '50px';
        if (ewEditorActive) ewInjectListeners();
        ewUpdateUndoRedo();
        ewSyncBack();
      }

      function ewUpdateUndoRedo() {
        const undo = doc.getElementById('__ew_undo__');
        const redo = doc.getElementById('__ew_redo__');
        if (undo) { undo.disabled = ewHistoryIndex <= 0; undo.style.opacity = ewHistoryIndex <= 0 ? '0.4' : '1'; }
        if (redo) { redo.disabled = ewHistoryIndex >= ewHistoryStack.length - 1; redo.style.opacity = ewHistoryIndex >= ewHistoryStack.length - 1 ? '0.4' : '1'; }
      }

      function ewSyncBack() {
        // Sync HTML back to main window
        const clean = ewGetCleanHtml();
        canvasRawHtml = clean;
        if (window.opener && !window.opener.closed) {
          window.opener.canvasRawHtml = clean;
        }
        editorWindowDirty = true;
      }

      function ewGetCleanHtml() {
        let html = '<!DOCTYPE html>' + doc.documentElement.outerHTML;
        // Remove editor toolbar
        html = html.replace(/<div id="__ew_toolbar__">[\s\S]*?<\/div>\s*/, '');
        // Remove editor styles and artifacts
        html = html.replace(/<style id="__editor_style__">[\s\S]*?<\/style>/g, '');
        html = html.replace(/<style id="__editor_spin_style__">[\s\S]*?<\/style>/g, '');
        html = html.replace(/<div class="__editor_toolbar__">[\s\S]*?<\/div>/g, '');
        html = html.replace(/<div class="__editor_comment_popup__">[\s\S]*?<\/div>/g, '');
        html = html.replace(/<div class="__editor_loader__">[\s\S]*?<\/div>/g, '');
        html = html.replace(/ ?class="__editor_hover__"/g, '');
        html = html.replace(/ ?class="__editor_collapsed__"/g, '');
        html = html.replace(/ style="position: relative;"/g, '');
        html = html.replace(/ style="padding-top: 50px;"/g, '');
        // Remove SEO panel if injected
        html = html.replace(/<div id="__ew_seo_panel__">[\s\S]*?<\/div>\s*<\/div>/g, '');
        return html;
      }

      // Toggle edit mode
      doc.getElementById('__ew_edit_toggle__').onchange = function() {
        ewEditorActive = this.checked;
        if (ewEditorActive) {
          if (ewHistoryStack.length === 0) ewPushSnapshot();
          ewInjectListeners();
        } else {
          removeEditorOverlays(doc);
        }
      };

      // Undo / Redo
      doc.getElementById('__ew_undo__').onclick = ewUndo;
      doc.getElementById('__ew_redo__').onclick = ewRedo;

      // Keyboard shortcuts
      doc.addEventListener('keydown', (e) => {
        if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
          e.preventDefault();
          ewUndo();
        }
        if ((e.ctrlKey || e.metaKey) && e.key === 'z' && e.shiftKey) {
          e.preventDefault();
          ewRedo();
        }
        // Ctrl+S = save
        if ((e.ctrlKey || e.metaKey) && e.key === 's') {
          e.preventDefault();
          ewSave();
        }
      });

      // Save to localStorage via opener
      function ewSave() {
        const clean = ewGetCleanHtml();
        canvasRawHtml = clean;
        if (window.opener && !window.opener.closed) {
          window.opener.canvasRawHtml = clean;
          if (window.opener.updateProjectHtml) window.opener.updateProjectHtml(clean);
          if (window.opener.updateProjectStatus) window.opener.updateProjectStatus('edited', clean);
          if (window.opener.saveState) window.opener.saveState();
        }

        editorWindowDirty = false;
        ewShowNotification('Сохранено');
      }

      doc.getElementById('__ew_save__').onclick = ewSave;

      // Download HTML
      doc.getElementById('__ew_download__').onclick = function() {
        const clean = ewGetCleanHtml();
        const niche = window.opener?.document?.getElementById('niche')?.value?.trim() || 'site';
        const dateStr = new Date().toISOString().slice(0, 10);
        const filename = `rating-${niche.replace(/[^a-zA-Zа-яА-Я0-9]/g, '_')}-${dateStr}.html`;

        const blob = new Blob([clean], { type: 'text/html; charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = doc.createElement('a');
        a.href = url;
        a.download = filename;
        a.click();
        URL.revokeObjectURL(url);
      };

      // SEO panel toggle
      doc.getElementById('__ew_seo__').onclick = function() {
        let panel = doc.getElementById('__ew_seo_panel__');
        if (panel) {
          panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
          return;
        }
        ewCreateSeoPanel();
      };

      function ewCreateSeoPanel() {
        const panel = doc.createElement('div');
        panel.id = '__ew_seo_panel__';
        Object.assign(panel.style, {
          position: 'fixed', top: '44px', right: '0', width: '360px', maxHeight: 'calc(100vh - 44px)',
          overflowY: 'auto', background: '#161b22', border: '1px solid #30363d', borderTop: 'none',
          zIndex: '99998', padding: '16px', fontFamily: '-apple-system,sans-serif', fontSize: '13px', color: '#e1e4e8'
        });
        const fields = [
          { id: 'counterYandex', label: 'Яндекс.Метрика', type: 'textarea' },
          { id: 'counterGoogle', label: 'Google Analytics / GTM', type: 'textarea' },
          { id: 'metaYandex', label: 'Яндекс.Вебмастер', type: 'input' },
          { id: 'metaGoogle', label: 'Google Search Console', type: 'input' },
          { id: 'metaTitle', label: 'Title', type: 'input' },
          { id: 'metaDesc', label: 'Description', type: 'textarea' },
          { id: 'metaKeywords', label: 'Keywords', type: 'input' },
          { id: 'metaOgImage', label: 'OG Image URL', type: 'input' }
        ];

        // Try to read current values from head
        const currentValues = ewReadSeoFromHead();

        panel.innerHTML = '<h3 style="margin:0 0 12px;font-size:14px;color:#fff;">SEO и счётчики</h3>' +
          fields.map(f => `
            <div style="margin-bottom:10px;">
              <label style="display:block;font-size:12px;color:#8b949e;margin-bottom:4px;">${f.label}</label>
              ${f.type === 'textarea'
                ? `<textarea id="__ew_${f.id}__" style="width:100%;min-height:60px;background:#0d1117;border:1px solid #30363d;border-radius:6px;padding:8px;color:#e1e4e8;font-size:12px;resize:vertical;">${currentValues[f.id] || ''}</textarea>`
                : `<input id="__ew_${f.id}__" value="${currentValues[f.id] || ''}" style="width:100%;background:#0d1117;border:1px solid #30363d;border-radius:6px;padding:8px;color:#e1e4e8;font-size:12px;">`}
            </div>
          `).join('') +
          '<button id="__ew_apply_seo__" style="width:100%;padding:8px;background:#238636;border:1px solid #238636;border-radius:6px;color:#fff;cursor:pointer;font-size:13px;">Применить</button>';

        doc.body.appendChild(panel);

        doc.getElementById('__ew_apply_seo__').onclick = function() {
          ewApplySeo();
        };
      }

      function ewReadSeoFromHead() {
        const vals = {};
        // Read meta title
        const title = doc.querySelector('title');
        if (title) vals.metaTitle = title.textContent;
        // Read meta description
        const desc = doc.querySelector('meta[name="description"]');
        if (desc) vals.metaDesc = desc.getAttribute('content') || '';
        // Read meta keywords
        const kw = doc.querySelector('meta[name="keywords"]');
        if (kw) vals.metaKeywords = kw.getAttribute('content') || '';
        // Read og:image
        const og = doc.querySelector('meta[property="og:image"]');
        if (og) vals.metaOgImage = og.getAttribute('content') || '';
        return vals;
      }

      function ewApplySeo() {
        ewPushSnapshot();
        const head = doc.head;

        // Apply counters inside PROTECTED:COUNTERS block
        const counterYandex = doc.getElementById('__ew_counterYandex__')?.value || '';
        const counterGoogle = doc.getElementById('__ew_counterGoogle__')?.value || '';
        let countersContent = '';
        if (counterYandex) countersContent += counterYandex + '\n';
        if (counterGoogle) countersContent += counterGoogle + '\n';

        const headHtml = head.innerHTML;
        if (headHtml.includes('<!-- PROTECTED:COUNTERS:START -->')) {
          head.innerHTML = headHtml.replace(
            /<!-- PROTECTED:COUNTERS:START -->[\s\S]*?<!-- PROTECTED:COUNTERS:END -->/,
            `<!-- PROTECTED:COUNTERS:START -->\n${countersContent}<!-- PROTECTED:COUNTERS:END -->`
          );
        }

        // Apply SEO meta inside PROTECTED:SEO block
        const metaYandex = doc.getElementById('__ew_metaYandex__')?.value || '';
        const metaGoogle = doc.getElementById('__ew_metaGoogle__')?.value || '';
        const metaTitle = doc.getElementById('__ew_metaTitle__')?.value || '';
        const metaDesc = doc.getElementById('__ew_metaDesc__')?.value || '';
        const metaKeywords = doc.getElementById('__ew_metaKeywords__')?.value || '';
        const metaOgImage = doc.getElementById('__ew_metaOgImage__')?.value || '';

        let seoContent = '';
        if (metaYandex) seoContent += `<meta name="yandex-verification" content="${metaYandex}">\n`;
        if (metaGoogle) seoContent += `<meta name="google-site-verification" content="${metaGoogle}">\n`;
        if (metaTitle) {
          const titleEl = doc.querySelector('title');
          if (titleEl) titleEl.textContent = metaTitle;
        }
        if (metaDesc) seoContent += `<meta name="description" content="${metaDesc}">\n`;
        if (metaKeywords) seoContent += `<meta name="keywords" content="${metaKeywords}">\n`;
        if (metaOgImage) seoContent += `<meta property="og:image" content="${metaOgImage}">\n`;

        const headHtml2 = head.innerHTML;
        if (headHtml2.includes('<!-- PROTECTED:SEO:START -->')) {
          head.innerHTML = headHtml2.replace(
            /<!-- PROTECTED:SEO:START -->[\s\S]*?<!-- PROTECTED:SEO:END -->/,
            `<!-- PROTECTED:SEO:START -->\n${seoContent}<!-- PROTECTED:SEO:END -->`
          );
        }

        ewSyncBack();
        ewShowNotification('SEO применено');
      }

      function ewShowNotification(msg) {
        let note = doc.getElementById('__ew_notification__');
        if (note) note.remove();
        note = doc.createElement('div');
        note.id = '__ew_notification__';
        Object.assign(note.style, {
          position: 'fixed', bottom: '20px', right: '20px', zIndex: '100000',
          background: '#238636', color: '#fff', padding: '10px 20px', borderRadius: '8px',
          fontSize: '13px', animation: 'fadeInOut 2.5s ease forwards'
        });
        // Add animation keyframes if needed
        if (!doc.getElementById('__ew_anim_style__')) {
          const animStyle = doc.createElement('style');
          animStyle.id = '__ew_anim_style__';
          animStyle.textContent = '@keyframes fadeInOut { 0%{opacity:0;transform:translateY(10px)} 15%{opacity:1;transform:translateY(0)} 80%{opacity:1} 100%{opacity:0} }';
          doc.head.appendChild(animStyle);
        }
        note.textContent = msg;
        doc.body.appendChild(note);
        setTimeout(() => note.remove(), 2500);
      }

      // Hover overlay + toolbar injection (same as 3B.2 but for editor window)
      function ewInjectListeners() {
        removeEditorOverlays(doc);
        injectEditorListeners(doc);

        // Override the callModel for regeneration to use editor window's apiKey
        // The existing injectEditorListeners/createBlockToolbar use the main window's functions
        // which reference iframe.contentDocument — but we're now using doc directly.
        // The functions (injectEditorListeners, createBlockToolbar, etc.) already accept iDoc parameter
        // so they work with any document. The regenerateBlock function uses document.getElementById("apiKey")
        // which will correctly reference the main window.
      }

      // Before unload warning
      win.addEventListener('beforeunload', (e) => {
        if (editorWindowDirty) {
          e.preventDefault();
          e.returnValue = 'Есть несохранённые изменения. Закрыть?';
        }
      });
    }

    function updatePreview() {
      const niche = document.getElementById("niche").value.trim();
      const geo = document.getElementById("geo").value.trim();
      const geoStr = geo ? ` в <span class="highlight">${geo}</span>` : '';
      document.getElementById("preview").innerHTML =
        `Составь список 30 <span class="highlight">${niche || "..."}</span>${geoStr}`;
    }

    function toggleApiKey() {
      const input = document.getElementById("apiKey");
      const btn = document.getElementById("toggleBtn");
      if (input.type === "password") {
        input.type = "text";
        btn.textContent = "скрыть";
      } else {
        input.type = "password";
        btn.textContent = "показать";
      }
    }

    function getBadgeClass(modelId) {
      if (modelId.includes("openai")) return "badge-chatgpt";
      if (modelId.includes("google")) return "badge-gemini";
      if (modelId.includes("anthropic")) return "badge-claude";
      return "";
    }

    function getBadgeLabel(modelId) {
      if (modelId.includes("openai")) return "ChatGPT";
      if (modelId.includes("google")) return "Gemini";
      if (modelId.includes("anthropic")) return "Claude";
      return "AI";
    }

    function renderCard(modelId) {
      const model = MODELS.find(m => m.id === modelId);
      const card = document.getElementById(`card-${CSS.escape(modelId)}`);
      if (!card || !model) return;

      const msgs = conversations[modelId] || [];
      const badgeClass = getBadgeClass(modelId);
      const badgeLabel = getBadgeLabel(modelId);

      let messagesHtml = "";
      for (const msg of msgs) {
        const isUser = msg.role === "user";
        messagesHtml += `
          <div class="chat-msg ${isUser ? "chat-msg-user" : "chat-msg-assistant"}">
            <div class="chat-msg-label">${isUser ? "Вы" : badgeLabel}</div>
            <div>${msg.content}</div>
          </div>`;
      }

      card.innerHTML = `
        <div class="result-header">
          <span class="model-badge ${badgeClass}">${badgeLabel}</span>
          <span class="model-name">${model.name}</span>
        </div>
        <div class="chat-messages" id="msgs-${CSS.escape(modelId)}">${messagesHtml}</div>
        <div class="chat-input-area">
          <input type="text" id="input-${CSS.escape(modelId)}" placeholder="Задать вопрос..." onkeydown="if(event.key==='Enter')sendFollowUp('${modelId}')" />
          <button onclick="sendFollowUp('${modelId}')">Отправить</button>
        </div>`;

      // Scroll chat to bottom
      const msgsEl = document.getElementById(`msgs-${CSS.escape(modelId)}`);
      if (msgsEl) msgsEl.scrollTop = msgsEl.scrollHeight;
    }

    async function sendFollowUp(modelId) {
      const apiKey = document.getElementById("apiKey").value.trim();
      const inputEl = document.getElementById(`input-${CSS.escape(modelId)}`);
      const question = inputEl.value.trim();
      if (!question || !apiKey) return;

      // Add user message with language context
      const followUpLang = document.getElementById("queryLang").value;
      const followUpLangStr = `Отвечай на языке: ${followUpLang}`;
      conversations[modelId].push({ role: "user", content: `ЯЗЫК ОТВЕТА: ${followUpLangStr}\n\n${question}` });
      inputEl.value = "";
      renderCard(modelId);

      // Show loading
      const msgsEl = document.getElementById(`msgs-${CSS.escape(modelId)}`);
      const loadingDiv = document.createElement("div");
      loadingDiv.className = "chat-msg chat-msg-assistant";
      loadingDiv.innerHTML = `<div class="chat-msg-label">${getBadgeLabel(modelId)}</div><div><span class="spinner-small"></span> Думает...</div>`;
      msgsEl.appendChild(loadingDiv);
      msgsEl.scrollTop = msgsEl.scrollHeight;

      // Disable input
      const btnEl = inputEl.nextElementSibling;
      inputEl.disabled = true;
      btnEl.disabled = true;

      try {
        const data = await callModel(modelId, conversations[modelId], apiKey);

        if (data.error) {
          conversations[modelId].push({ role: "assistant", content: `[Ошибка] ${data.error}` });
        } else {
          conversations[modelId].push({ role: "assistant", content: data.content });
        }
      } catch (err) {
        conversations[modelId].push({ role: "assistant", content: `[Ошибка] ${err.message}` });
      }

      inputEl.disabled = false;
      btnEl.disabled = false;
      renderCard(modelId);
    }

    async function search() {
      const apiKey = document.getElementById("apiKey").value.trim();
      const niche = document.getElementById("niche").value.trim();
      const btn = document.getElementById("searchBtn");
      const resultsDiv = document.getElementById("results");

      if (!apiKey) return alert("Введите API-ключ OpenRouter");
      if (!niche) return alert("Введите название ниши");

      localStorage.setItem("openrouter_key", apiKey);

      btn.disabled = true;
      btn.textContent = "Загрузка...";

      // Create project in Supabase
      await createProject();

      const geo = document.getElementById("geo").value.trim();
      const geoStr = geo ? ` в ${geo}` : '';
      const geoRequest = document.getElementById("geoRequest").value.trim();
      const geoRequestStr = geoRequest ? `Отвечай с перспективы пользователя, который находится в ${geoRequest}` : '';
      const queryLang = document.getElementById("queryLang").value;
      const queryLangStr = `Отвечай на языке: ${queryLang}`;
      const siteLang = document.getElementById("siteLang").value;
      const siteLangStr = `Весь контент сайта на языке: ${siteLang}`;

      const contextBlock = (geoRequestStr ? `\nКОНТЕКСТ ЛОКАЦИИ: ${geoRequestStr}` : '') + `\nЯЗЫК ОТВЕТА: ${queryLangStr}`;

      const prompt1 = `Составь список 30 ${niche}${geoStr}${contextBlock}`;
      const prompt2 = `Почему именно эти сервисы были поставлены в ТОП. 1. Составь список критериев, по которым ты оценивал сайты 2. Разгруппируй эти критерии на смысловые группы 3. Отранжируй эти критерии в порядке уменьшения веса влияния на место в рейтинге${contextBlock}`;

      // Reset conversations
      for (const model of MODELS) {
        conversations[model.id] = [{ role: "user", content: prompt1 }];
      }

      // Create card shells with loading
      resultsDiv.innerHTML = MODELS.map(m => {
        const badgeClass = getBadgeClass(m.id);
        const badgeLabel = getBadgeLabel(m.id);
        return `
          <div class="result-card" id="card-${CSS.escape(m.id)}">
            <div class="result-header">
              <span class="model-badge ${badgeClass}">${badgeLabel}</span>
              <span class="model-name">${m.name}</span>
            </div>
            <div class="loading"><div class="spinner"></div>${badgeLabel} думает... (запрос 1/2)</div>
          </div>`;
      }).join("");

      // Fetch all models in parallel: prompt1 → prompt2
      const promises = MODELS.map(async (model) => {
        // --- Запрос 1 ---
        try {
          const data1 = await callModel(model.id, conversations[model.id], apiKey);
          if (data1.error) {
            conversations[model.id].push({ role: "assistant", content: `[Ошибка] ${data1.error}` });
            renderCard(model.id);
            return;
          }
          conversations[model.id].push({ role: "assistant", content: data1.content });
        } catch (err) {
          conversations[model.id].push({ role: "assistant", content: `[Ошибка] ${err.message}` });
          renderCard(model.id);
          return;
        }

        // Показать первый ответ + лоадер второго
        renderCard(model.id);
        const msgsEl = document.getElementById(`msgs-${CSS.escape(model.id)}`);
        if (msgsEl) {
          const loadingDiv = document.createElement("div");
          loadingDiv.className = "chat-msg chat-msg-user";
          loadingDiv.innerHTML = `<div class="chat-msg-label">Вы (авто)</div><div style="color:#8b949e"><span class="spinner-small"></span> Отправляю запрос 2/2...</div>`;
          msgsEl.appendChild(loadingDiv);
          msgsEl.scrollTop = msgsEl.scrollHeight;
        }

        // --- Запрос 2 (с контекстом) ---
        conversations[model.id].push({ role: "user", content: prompt2 });

        try {
          const data2 = await callModel(model.id, conversations[model.id], apiKey);
          if (data2.error) {
            conversations[model.id].push({ role: "assistant", content: `[Ошибка] ${data2.error}` });
          } else {
            conversations[model.id].push({ role: "assistant", content: data2.content });
          }
        } catch (err) {
          conversations[model.id].push({ role: "assistant", content: `[Ошибка] ${err.message}` });
        }

        renderCard(model.id);
      });

      await Promise.all(promises);
      saveState(); // Save after step 1-2
      updateProjectMeta({ currentStep: 'step_1_2' });

      let grokCriteriaRaw = "";
      let grokAudienceRaw = "";

      // --- Запрос 3: Grok Deep Research ---
      btn.textContent = "Анализ критериев (Grok)...";

      // Собрать последний ответ (критерии) от каждой модели
      const criteriaBlocks = MODELS.map(m => {
        const msgs = conversations[m.id] || [];
        const lastAssistant = [...msgs].reverse().find(msg => msg.role === "assistant");
        return `=== ${m.name} ===\n${lastAssistant?.content || "(нет ответа)"}`;
      }).join("\n\n");

      const grokPrompt = `ЯЗЫК ОТВЕТА: ${queryLangStr}

Представь, что ты человек, который провел ресерч данной ниши и тебе необходимо составить собственный рейтинг, который будет оценивать каждую компанию по определенным критериям.

Тебе необходимо выполнить смысловую дедупликацию критериев
Составить итоговую таблицу с критериями (В первом столбце критерий, а во втором столбце методология его оценки)
При разборе запрещается пропускать критерии

ВАЖНО: В ответе выведи ТОЛЬКО итоговую таблицу. Без вступления, без пояснений, без заключения. Только таблица.

Список критериев ниже:
<data>
${criteriaBlocks}
</data>`;

      const grokSection = document.getElementById("grok-section");
      const grokMessages = document.getElementById("grok-messages");
      grokSection.style.display = "block";
      grokMessages.innerHTML = `<div class="loading"><div class="spinner"></div>Grok Deep Research анализирует критерии...</div>`;
      grokSection.scrollIntoView({ behavior: "smooth" });

      try {
        const grokData = await callModel("x-ai/grok-4", [{ role: "user", content: grokPrompt }], apiKey);
        if (grokData.error) {
          grokMessages.innerHTML = `<div class="chat-msg chat-msg-assistant"><div class="chat-msg-label">Grok</div><div class="error-text">[Ошибка] ${grokData.error}</div></div>`;
        } else {
          grokCriteriaRaw = grokData.content;
          const tableHtml = mdTableToHtml(grokData.content);
          const rendered = tableHtml
            ? `<div class="grok-table-wrap">${tableHtml}</div>`
            : `<div style="white-space:pre-wrap">${grokData.content}</div>`;
          grokMessages.innerHTML = `
            <div class="chat-msg chat-msg-assistant" style="padding:20px;">
              ${rendered}
            </div>`;
        }
      } catch (err) {
        grokMessages.innerHTML = `<div class="chat-msg chat-msg-assistant"><div class="chat-msg-label">Grok</div><div class="error-text">[Ошибка] ${err.message}</div></div>`;
      }

      saveState(); // Save after Grok criteria
      updateProjectMeta({ currentStep: 'step_3_criteria', grokCriteriaRaw });

      // --- Запрос 4: Аудитории и боли ---
      btn.textContent = "Анализ аудиторий (Grok)...";

      const audiencePrompt = `ЯЗЫК ОТВЕТА: ${queryLangStr}

Ты — маркетолог-аналитик и UX-специалист. Тебе дана ниша: "${niche}".

Смоделируй 4 сегмента целевой аудитории для компаний в этой нише.

Для каждого сегмента ЦА составь подробный список их болей, вопросов и интентов (не менее 15–20 пунктов).

Ответ выведи в два блока:

БЛОК 1 — markdown-таблица с двумя столбцами. Каждая боль/интент — ОТДЕЛЬНАЯ строка.

| ЦА | Боль / Интент |
|---|---|
| Малый бизнес | Хочу понять стоимость до покупки |
| Малый бизнес | Боюсь сложной интеграции |
| Корпорации | Нужна масштабируемость |

БЛОК 2 — после таблицы, через разделитель "---", выведи краткие портреты каждой ЦА в формате:

---
**Малый бизнес:** Владелец компании до 50 чел., ищет автоматизацию...
**Корпорации:** IT-директор крупной компании...

Без вступления и заключения.`;

      const audienceSection = document.getElementById("audience-section");
      const audienceMessages = document.getElementById("audience-messages");
      audienceSection.style.display = "block";
      audienceMessages.innerHTML = `<div class="loading"><div class="spinner"></div>Grok анализирует аудитории и боли...</div>`;
      audienceSection.scrollIntoView({ behavior: "smooth" });

      try {
        const audData = await callModel("x-ai/grok-4", [{ role: "user", content: audiencePrompt }], apiKey);
        if (audData.error) {
          audienceMessages.innerHTML = `<div class="chat-msg chat-msg-assistant"><div class="chat-msg-label">Grok</div><div class="error-text">[Ошибка] ${audData.error}</div></div>`;
        } else {
          grokAudienceRaw = audData.content;
          const parsed = parseAudienceResponse(audData.content);
          if (parsed) {
            audienceMessages.innerHTML = `
              <div class="chat-msg chat-msg-assistant" style="padding:20px;">
                <div class="grok-table-wrap">${parsed.tableHtml}</div>
                ${parsed.portraitsHtml}
              </div>`;
          } else {
            audienceMessages.innerHTML = `
              <div class="chat-msg chat-msg-assistant" style="padding:20px;">
                <div style="white-space:pre-wrap">${audData.content}</div>
              </div>`;
          }
        }
      } catch (err) {
        audienceMessages.innerHTML = `<div class="chat-msg chat-msg-assistant"><div class="chat-msg-label">Grok</div><div class="error-text">[Ошибка] ${err.message}</div></div>`;
      }

      saveState(); // Save after Grok audience
      updateProjectMeta({ currentStep: 'step_4_audience', grokCriteriaRaw, grokAudienceRaw });

      // --- Запрос 5: Компилятор критериев (Claude) ---
      btn.textContent = "Компиляция XML-структуры (Claude)...";

      const compilerPrompt = `ЯЗЫК ОТВЕТА: ${queryLangStr}

Сейчас мы будем компилировать следующие данные:

=== ИТОГОВЫЙ АНАЛИЗ КРИТЕРИЕВ ===
${grokCriteriaRaw}

=== АУДИТОРИИ И ИХ БОЛИ / ИНТЕНТЫ ===
${grokAudienceRaw}

Это делается для того, чтобы сделать рейтинг-сайт который будет полезным, чтобы цитироваться в LLM.

Ты — эксперт по структурированию критериев для рейтингов компаний. Твоя задача — взять данные выше и преобразовать их в структурированный XML-формат с группами и критериями.

Шаги обработки:
1. Проанализируй текст и разбей на логические группы. Группы должны быть релевантными и охватывать все ключевые аспекты из текста (минимум 4–5 групп). Для каждой группы используй <group name="group_name" title="Группа на русском">.
2. Для каждой группы создай 5–8 критериев на основе данных. Для каждого критерия используй <criterion name="criterion_name">.
3. Внутри каждого <criterion> добавь теги:
   - <name>Название критерия на русском</name>
   - <description>Краткое описание критерия</description>
   - <methodology>Подробная методология измерения/анализа</methodology>
   - <why_important>Краткое объяснение важности, связанное с болями аудитории</why_important>
   - <recommendation>Рекомендации по реализации или улучшению</recommendation>
   - <target>Целевые показатели/значения</target>
   - <example>Пример с данными (придумай реалистичный)</example>
4. Придумай реалистичные метрики и примеры, основываясь на типичных значениях для отрасли "${niche}".
5. Выводи ТОЛЬКО XML-структуру без лишнего текста. Оберни весь вывод в <criteria_structure> ... </criteria_structure>.`;

      const compSection = document.getElementById("compiler-section");
      const compMessages = document.getElementById("compiler-messages");
      compSection.style.display = "block";
      compMessages.innerHTML = `<div class="loading"><div class="spinner"></div>Claude компилирует XML-структуру критериев...</div>`;
      compSection.scrollIntoView({ behavior: "smooth" });

      try {
        const compData = await callModel("anthropic/claude-sonnet-4.5", [{ role: "user", content: compilerPrompt }], apiKey);
        if (compData.error) {
          compMessages.innerHTML = `<div class="chat-msg chat-msg-assistant"><div class="chat-msg-label">Claude</div><div class="error-text">[Ошибка] ${compData.error}</div></div>`;
        } else {
          compilerRawXml = compData.content.replace(/^```xml\s*\n?/i, '').replace(/\n?```\s*$/i, '').trim();
          compMessages.innerHTML = `
            <div class="chat-msg chat-msg-assistant" style="padding:20px;">
              <button class="copy-btn" onclick="navigator.clipboard.writeText(compilerRawXml).then(()=>{this.textContent='Скопировано!';setTimeout(()=>this.textContent='Копировать XML',1500)})">Копировать XML</button>
              <div class="xml-output">${highlightXml(compData.content)}</div>
            </div>`;
        }
      } catch (err) {
        compMessages.innerHTML = `<div class="chat-msg chat-msg-assistant"><div class="chat-msg-label">Claude</div><div class="error-text">[Ошибка] ${err.message}</div></div>`;
      }

      saveState(); // Save after compiler XML
      updateProjectMeta({ currentStep: 'step_5_compiler', compilerRawXml, grokCriteriaRaw, grokAudienceRaw });

      // --- Запрос 6: Генерация сайта (Claude) ---
      btn.textContent = "Генерация сайта (Claude)...";

      const sitePrompt = `ЯЗЫК САЙТА: ${siteLangStr}

РОЛЬ:

Ты — Senior SEO-специалист, эксперт по GEO (Generative Engine Optimization) и Fullstack-разработчик.
Ты создаёшь не шаблоны, а memorable, high-craft интерфейсы с чётким aesthetic point of view.
Твоя задача — создать независимый рейтинговый портал (агрегатор) по теме "${niche}"${geoStr}.

ЦЕЛЬ:

Создать единую, полностью самодостаточную HTML-страницу (один файл, inline CSS и JS), которая:

Идеально ранжируется по запросам, связанным с рейтингом компаний в данной нише.

Оптимизирована для цитирования нейросетями (ChatGPT, Gemini, Perplexity). Страница должна стать источником "Ground Truth" для AI.

———————————————————————————
ДИЗАЙН-СИСТЕМА (ОБЯЗАТЕЛЬНАЯ К ИСПОЛНЕНИЮ)
———————————————————————————

AESTHETIC DIRECTION: Editorial / Magazine — строгий, экспертный, с характером.
Если ниша технологическая — допустим сдвиг к Industrial / Utilitarian.

ТИПОГРАФИКА (КРИТИЧЕСКИ ВАЖНО):
- ЗАПРЕЩЕНЫ: Inter, Roboto, Arial, system-ui, sans-serif по умолчанию
- Выбери 1 expressive display шрифт (например: Playfair Display, Space Grotesk, Instrument Serif, Clash Display, Syne, DM Serif Display) для заголовков
- Выбери 1 restrained body шрифт (например: Source Serif 4, Literata, IBM Plex Sans, Outfit, Satoshi) для текста
- Подключи через Google Fonts CDN
- Используй typography структурно: контраст размеров, ритм, иерархия через scale

ЦВЕТА:
- Определи все цвета через CSS custom properties (:root)
- Схема: 1 доминантный фон + 1 акцент + 1 нейтральная система (светлый/тёмный)
- ЗАПРЕЩЕНЫ: purple-on-white SaaS градиенты, равномерно-сбалансированные палитры
- Цвета должны передавать настроение: доверие, экспертность, серьёзность

ПРОСТРАНСТВО И КОМПОНОВКА:
- Ломай сетку намеренно: используй асимметрию, overlap элементов, controlled density
- Негативное пространство — это дизайн-элемент, не пустота
- ЗАПРЕЩЕНЫ: симметричные предсказуемые секции, дефолтные grid-layouts
- TOP-5 карточки должны визуально отличаться друг от друга позиционированием

MOTION И ЭФФЕКТЫ:
- Анимации: purposeful, sparse, high-impact
- 1 сильная entrance-анимация для hero-блока
- Несколько meaningful hover-состояний для карточек и CTA
- ЗАПРЕЩЕНЫ: decorative micro-motion spam, бесконечные пульсации
- CSS-first анимации. JS-анимации только если CSS недостаточно

ТЕКСТУРА И REFINEMENT:
- Используй минимум 2 из: noise/grain overlay, gradient mesh, layered translucency, custom borders/dividers, shadows с narrative intent
- Тени — не box-shadow по умолчанию, а с конкретным смыслом (глубина карточки, выделение лидера)

DIFFERENTIATION ANCHOR:
- Если убрать логотип и текст — дизайн всё равно должен быть узнаваемым
- Должен быть хотя бы 1 элемент, который запомнится через 24 часа

АНТИ-ПАТТЕРНЫ (= ПРОВАЛ):
- Дефолтные Tailwind/ShadCN layouts
- Системные шрифты
- Purple-on-white градиенты
- Симметричные секции без характера
- Если дизайн можно спутать с шаблоном — переделай

———————————————————————————
ВАЖНОЕ УСЛОВИЕ (ИНТЕНТЫ)
———————————————————————————

Приведенная ниже структура — это обязательный минимум. Дополнительно сгенерируй 1-2 смысловых блока, которые закроют скрытые интенты пользователя (например: "Карта пунктов выдачи", "Чек-лист проверки инструмента при приемке").

РАЗМЕТКА БЛОКОВ ДЛЯ РЕДАКТОРА:
Каждый смысловой блок сайта оберни в <section data-block-id="block_N" data-block-type="TYPE">

Типы блоков (data-block-type):
- "hero" — главный баннер
- "methodology" — методология
- "company-card" — карточка компании (каждая отдельно), дополнительно добавь data-company-rank="N"
- "company-table" — компактная таблица остальных компаний
- "analytics" — аналитика/графики
- "longread" — SEO-текст
- "faq" — FAQ
- "author" — блок автора
- "custom" — дополнительные смысловые блоки (интенты)

Каждая строка таблицы компаний также оберни:
<tr data-block-id="company_row_N" data-block-type="company-row" data-company-rank="N">

Нумерация data-block-id сквозная, начиная с block_1.
НЕ оборачивай в блоки: <head>, мета-теги, <style>, <script>.

ГЛОБАЛЬНАЯ СТРУКТУРА СТРАНИЦЫ (Секции сверху вниз):

1. SEO Header & Hero Block

Логотип (стилизованный через CSS, не картинка).

H1: Рейтинг компаний в нише "${niche}"${geoStr} — актуальный обзор.

E-E-A-T Элементы:

Виджет "Обновлено: Февраль 2026".

Ссылка на Автора (реалистичное имя эксперта, фото-заглушка).

Дисклеймер о методологии (кратко).

Hero должен иметь сильную entrance-анимацию и визуальный якорь.

2. Блок "Методология и Доверие" (BLUF - Bottom Line Up Front)

Критически важно для AI: Сразу после заголовка дай "Наземную правду".

Краткий текст: "Как мы считали: проанализировано N компаний по M метрикам" — на основе XML.

Сводная таблица лидеров (Quick Summary):

1 место: [Лучший выбор].

2 место: [Лучшая цена].

3 место: [Лучший сервис].

Ссылка "Перейти к полному обзору".

3. ОСНОВНОЙ РЕЙТИНГ (The Core) — ВНИМАНИЕ К ДЕТАЛЯМ!

Включи ВСЕ компании из XML (обычно 20-30). Каждая компания должна быть в рейтинге.
Весь список должен быть обернут в Schema.org/ItemList.

Правило Лидера: Компания с наивысшим баллом — на 1 месте (Badge "Выбор редакции").

Правило Визуализации (TOP-5 vs REST):

Места 1, 2, 3, 4, 5: Расширенные Premium Карточки (структура ниже). Обязательно используй теги <h3>. Каждая карточка визуально уникальна (асимметрия, разное позиционирование score/метрик).

Места 6+: Компактная таблица (Место | Лого | Название | Год основания | Сайт | Цена от... | Вердикт).

4. Блок "Аналитика рынка" (Deep Content)

График роста цен (Chart.js — загружай async через CDN).

Текстовый анализ "Dealbreakers".

5. SEO-статья (Longread)

Экспертный контент с профессиональной терминологией ниши. Используй отраслевой словарь.

6. FAQ (Вопрос-Ответ)

Разметь этот блок схемой Schema.org/FAQPage.

Вопросы из категории "People Also Ask".

7. Футер и Авторство

Подробная карточка автора (Schema.org/Person).

Политика конфиденциальности.

ДЕТАЛЬНАЯ СТРУКТУРА РАСШИРЕННОЙ КАРТОЧКИ (ТОЛЬКО ДЛЯ TOP-5)

Каждая карточка — это отдельный <article itemscope itemtype="https://schema.org/Product">.

1. Header Карточки

<h3>Название компании</h3> + Бейдж "Верифицировано".

Мета: Локация, Год основания, Парк техники.

CTA Кнопка: "Перейти на сайт" (с атрибутом rel="nofollow"). Кнопка со стилизованным hover-эффектом.

2. Score & AI Summary (Ground Truth)

Общий балл (X.X/10) — визуализирован как кастомный элемент (не просто цифра, а progress ring или styled badge).

AI Summary: Факты, а не вода. Конкретные цифры.

3. Блок "Dealbreakers" (Для AI-Refinements)

Лучше всего подходит для: (конкретные сегменты ЦА).

Может не подойти, если: (конкретные ограничения).

4. Сетка Метрик

Прогресс-бар для каждой метрики из XML (кастомный дизайн, не браузерный <progress>).

Теги преимуществ.

Цены и Условия.

5. Кейс и Отзыв

Кейс: Проблема -> Решение -> Результат.

Отзыв: Цитата с разметкой Schema.org/Review.

ТЕХНИЧЕСКИЕ ТРЕБОВАНИЯ:

1. Микроразметка (Schema.org) — ОБЯЗАТЕЛЬНО

Внедри JSON-LD для: ItemList, Organization (для каждой компании: name, url, aggregateRating), FAQPage, Person, Article.

ПРАВИЛА Schema.org JSON-LD:
- FAQPage: один блок <script type="application/ld+json"> с @type: "FAQPage" и mainEntity: массив Question. НЕ создавай отдельные JSON-LD блоки для каждого Question — они должны быть ТОЛЬКО внутри FAQPage.mainEntity.
- Person: один блок. Если автор упоминается в Article и в Footer — используй @id и ссылайся на него, не дублируй.
- Каждый JSON-LD блок — отдельный <script type="application/ld+json">. Но сущности НЕ дублируются между блоками.

2. Структура и Код (Mobile-First)

Используй семантические теги: <main>, <article>, <section>, <aside>, <time>.

Core Web Vitals: Код должен быть легким. НЕ используй Tailwind — пиши чистый modern CSS с custom properties и CSS Grid/Flexbox. Chart.js (CDN async).

Шрифты: подключи выбранную пару через Google Fonts CDN.

CSS-first анимации. Framer Motion и подобные библиотеки запрещены.

Accessible by default: contrast ratio, focus states, keyboard navigation.

3. Контент (E-E-A-T)

Факты: Используй цифры, проценты, конкретные сроки. Избегай прилагательных "лучший", "качественный" без доказательств.

Словарь: Используй профессиональную терминологию ниши.

4. ВЕСЬ КОД В ОДНОМ HTML-ФАЙЛЕ. Inline styles и scripts допустимы.

5. ЗАЩИТНЫЕ МАРКЕРЫ В <head>:
Добавь в <head> пустые маркеры для внешних счётчиков и мета-тегов:
<!-- PROTECTED:SEO:START --><!-- PROTECTED:SEO:END -->
<!-- PROTECTED:COUNTERS:START --><!-- PROTECTED:COUNTERS:END -->
НЕ помещай свои мета-теги (og:title, description и т.д.) между этими маркерами.
Маркеры должны быть ПОСЛЕ всех твоих мета-тегов и ПЕРЕД </head>.

6. Выведи ТОЛЬКО HTML-код. Без пояснений, без markdown, без тройных бэктиков. Просто чистый HTML начиная с <!DOCTYPE html>.

ВХОДНЫЕ ДАННЫЕ (XML):

${compilerRawXml}`;

      const canvasSection = document.getElementById("canvas-section");
      const canvasLoading = document.getElementById("canvas-loading");
      const canvasToolbar = document.getElementById("canvas-toolbar");
      const canvasPreview = document.getElementById("canvas-preview");
      const canvasCodeView = document.getElementById("canvas-code-view");

      canvasSection.style.display = "block";
      canvasLoading.style.display = "flex";
      canvasToolbar.style.display = "none";
      canvasPreview.style.display = "none";
      canvasCodeView.style.display = "none";
      canvasSection.scrollIntoView({ behavior: "smooth" });

      try {
        const siteData = await callModel("anthropic/claude-sonnet-4.5", [{ role: "user", content: sitePrompt }], apiKey);

        if (siteData.error) {
          canvasLoading.innerHTML = `<div class="error-text" style="padding:20px;">[Ошибка] ${siteData.error}</div>`;
        } else {
          // Extract HTML from response (strip markdown fences if present)
          let html = siteData.content;
          html = html.replace(/^```html?\s*\n?/i, '').replace(/\n?```\s*$/i, '').trim();

          canvasRawHtml = html;

          // Hide loading, show toolbar + preview + editor toolbar
          canvasLoading.style.display = "none";
          canvasToolbar.style.display = "flex";
          document.getElementById("editor-toolbar").style.display = "flex";
          canvasPreview.style.display = "block";

          // Reset editor state
          editorActive = false;
          document.getElementById('editor-mode-toggle').checked = false;
          historyStack = [];
          historyIndex = -1;
          updateUndoRedoButtons();

          // Render in iframe
          const iframe = document.getElementById("canvas-iframe");
          iframe.srcdoc = html;

          // Set code view
          const codeContent = document.getElementById("canvas-code-content");
          codeContent.textContent = html;
        }
      } catch (err) {
        canvasLoading.innerHTML = `<div class="error-text" style="padding:20px;">[Ошибка] ${err.message}</div>`;
      }

      saveState(); // Save after canvas generation (most expensive step)
      updateProjectStatus('generated', canvasRawHtml);
      updateProjectMeta({ currentStep: 'step_6', compilerRawXml, grokCriteriaRaw, grokAudienceRaw });

      // --- Запрос 6.5: Perplexity — поиск рейтингов ---
      btn.textContent = "Поиск рейтингов (Perplexity)...";

      const ratingsSection = document.getElementById("ratings-section");
      const ratingsLoading = document.getElementById("ratings-loading");
      ratingsSection.style.display = "block";
      ratingsLoading.style.display = "flex";
      document.getElementById('ratings-progress').textContent = '';
      ratingsSection.scrollIntoView({ behavior: "smooth" });

      const perplexityPrompt = `${geoRequestStr ? 'КОНТЕКСТ ЛОКАЦИИ: ' + geoRequestStr + '\n' : ''}ЯЗЫК ОТВЕТА: ${queryLangStr}

Найди 10-15 лучших рейтингов и обзоров компаний по теме "${niche}"${geoStr} в интернете.

Для каждого рейтинга укажи:
- Название статьи/сайта
- Прямой URL страницы рейтинга

Ищи именно страницы-рейтинги, обзоры, сравнения, ТОП-листы — где уже собрана структурированная информация о компаниях данной ниши.

ВАЖНО: Верни ТОЛЬКО JSON-массив и НИЧЕГО больше. Без markdown, без пояснений, без бэктиков.
Формат:
[{"name": "Название рейтинга", "url": "https://..."}]`;

      try {
        const perplexityData = await callModel("perplexity/sonar-pro", [{ role: "user", content: perplexityPrompt }], apiKey);
        ratingsLoading.style.display = "none";

        if (perplexityData.error) {
          document.getElementById('ratings-progress').textContent = `Ошибка Perplexity: ${perplexityData.error}`;
        } else {
          let jsonStr = perplexityData.content.replace(/^```json?\s*\n?/i, '').replace(/\n?```\s*$/i, '').trim();

          // Try to extract JSON from response (Perplexity may add text around it)
          const jsonMatch = jsonStr.match(/\[[\s\S]*\]/);
          if (jsonMatch) jsonStr = jsonMatch[0];

          try {
            const ratings = JSON.parse(jsonStr);

            // Deduplicate by URL domain
            const seenUrls = new Set();
            extractedRatings = ratings.filter(r => {
              if (!r.url) return false;
              try {
                const domain = new URL(r.url).hostname;
                if (seenUrls.has(domain)) return false;
                seenUrls.add(domain);
                return true;
              } catch { return false; }
            }).map(r => ({ name: r.name, url: r.url, status: 'pending' }));

            renderRatingsGrid();

            // Download all rating pages with concurrency limit of 5
            const rQueue = [...extractedRatings.keys()];

            async function processRatingQueue() {
              while (rQueue.length > 0) {
                const idx = rQueue.shift();
                await downloadRatingSite(extractedRatings[idx], idx);
              }
            }

            const rWorkers = Array.from(
              { length: Math.min(5, extractedRatings.length) },
              () => processRatingQueue()
            );

            await Promise.all(rWorkers);

          } catch (parseErr) {
            document.getElementById('ratings-progress').textContent = `Ошибка парсинга JSON: ${parseErr.message}. Ответ: ${perplexityData.content.substring(0, 200)}`;
          }
        }
      } catch (err) {
        ratingsLoading.style.display = "none";
        document.getElementById('ratings-progress').textContent = `Ошибка: ${err.message}`;
      }

      // --- Запрос 7a: Извлечение компаний + скачивание сайтов ---
      btn.textContent = "Загрузка сайтов компаний...";

      const sitesSection = document.getElementById("sites-section");
      sitesSection.style.display = "block";
      sitesSection.scrollIntoView({ behavior: "smooth" });

      // Collect step 1 responses (first assistant message from each model)
      const step1Responses = MODELS.map(m => {
        const msgs = conversations[m.id] || [];
        const firstAssistant = msgs.find(msg => msg.role === "assistant");
        return `=== ${m.name} ===\n${firstAssistant?.content || "(нет ответа)"}`;
      }).join("\n\n");

      const extractPrompt = `ЯЗЫК ОТВЕТА: ${queryLangStr}

Из текста ниже извлеки все уникальные компании. Для каждой компании определи название и URL основного сайта.

ПРАВИЛА:
1. Объедини дубликаты (одна и та же компания от разных моделей = одна запись).
2. URL должен начинаться с https:// и быть основным доменом компании.
3. Если URL не указан в тексте, попытайся определить его по названию компании.
4. Верни JSON-массив и НИЧЕГО больше. Без markdown, без пояснений, без бэктиков.

Формат ответа (строго JSON):
[{"name": "Company Name", "url": "https://example.com"}, ...]

Текст:
${step1Responses}`;

      document.getElementById('download-progress').textContent = 'AI извлекает список компаний и URL...';

      try {
        const extractData = await callModel("anthropic/claude-sonnet-4.5", [{ role: "user", content: extractPrompt }], apiKey);

        if (extractData.error) {
          document.getElementById('download-progress').textContent = `Ошибка извлечения: ${extractData.error}`;
        } else {
          let jsonStr = extractData.content.replace(/^```json?\s*\n?/i, '').replace(/\n?```\s*$/i, '').trim();

          try {
            const companies = JSON.parse(jsonStr);

            // Deduplicate by lowercased name
            const seen = new Set();
            extractedCompanies = companies.filter(c => {
              const key = c.name.toLowerCase().trim();
              if (seen.has(key)) return false;
              seen.add(key);
              return true;
            }).map(c => ({ name: c.name, url: c.url, status: 'pending' }));

            renderCompaniesGrid();

            // Download only TOP-5 company sites (or TOP-4 if user company injection exists)
            const hasUserCompany = !!document.getElementById("user-company-data").value.trim();
            const topN = hasUserCompany ? 4 : 5; // #1 = user company, so download 4 others
            const topIndices = extractedCompanies
              .map((_, i) => i)
              .slice(0, topN);

            const queue = [...topIndices];

            async function processQueue() {
              while (queue.length > 0) {
                const idx = queue.shift();
                await downloadCompanySite(extractedCompanies[idx], idx);
              }
            }

            const workers = Array.from(
              { length: Math.min(5, queue.length) },
              () => processQueue()
            );

            await Promise.all(workers);

          } catch (parseErr) {
            document.getElementById('download-progress').textContent = `Ошибка парсинга JSON: ${parseErr.message}`;
          }
        }
      } catch (err) {
        document.getElementById('download-progress').textContent = `Ошибка: ${err.message}`;
      }

      saveState(); // Save at the end of full pipeline
      updateProjectMeta({
        currentStep: 'step_8_web',
        compilerRawXml,
        grokCriteriaRaw,
        grokAudienceRaw,
        extractedCompanies,
        extractedRatings
      });

      btn.disabled = false;
      btn.textContent = "Найти компании";
    }

    // Restore saved API key
    const savedKey = localStorage.getItem("openrouter_key");
    if (savedKey) document.getElementById("apiKey").value = savedKey;

    // Restore pipeline state from localStorage
    loadState();

    // Load projects list from Supabase
    loadProjects();
  </script>
</body>
</html>
